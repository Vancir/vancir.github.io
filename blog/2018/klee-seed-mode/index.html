<!DOCTYPE html> <html lang="en"> <head> <meta name="google-site-verification" content="kFTGHTKWYnz7RkFa5Fi4_Tfdijlcl0sWeQbJo40mXOw"/> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>KLEE中Seed模式流程解析及相关选项介绍 | Song Liu</title> <meta name="author" content="Song Liu"/> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@200&display=swap" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/favicon.ico"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://vancir.github.io/blog/2018/klee-seed-mode/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://vancir.github.io/">Song Liu</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" target="_blank" href="/assets/pdf/resume.pdf">Resume</a> </li> <div class="toggle-container"> <a id="light-toggle"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </a> </div> </ul> </div> </div> </nav> </header> <div class="container mt-4"> <div class="post"> <header class="post-header"> <h1 class="post-title">KLEE中Seed模式流程解析及相关选项介绍</h1> <p class="post-meta">September 9, 2018</p> <p class="post-tags"> <a href="/blog/2018"> <i class="fas fa-calendar fa-sm"></i> 2018 </a>   ·   <a href="/blog/tag/klee"> <i class="fas fa-hashtag fa-sm"></i> klee</a>   <a href="/blog/tag/symexe"> <i class="fas fa-hashtag fa-sm"></i> symexe</a>   </p> </header> <article class="post-content"> <h2 id="maincpp">main.cpp</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
  <span class="n">SeedOutFile</span><span class="p">(</span><span class="s">"seed-out"</span><span class="p">);</span>

  <span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
  <span class="n">SeedOutDir</span><span class="p">(</span><span class="s">"seed-out-dir"</span><span class="p">);</span>
</code></pre></div></div> <p>在main.cpp中首先会对ReplayKTestDir和ReplayKTestFile做判断. 如果用户有指定, 那么会继续判断SeedOutDir和SeedOutFile是否为空.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReplayKTestDir</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">ReplayKTestFile</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">SeedOutFile</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">SeedOutDir</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
     <span class="p">...</span>
     <span class="c1">// replay ktest 文件模式</span>
 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="c1">// 没有指定replay ktest模式</span>
     <span class="c1">// 直接从SeedOutFile读取seed</span>
     <span class="k">for</span><span class="p">(){</span>
         <span class="n">KTest</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">kTest_fromFile</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">());</span>
     <span class="p">}</span>
     <span class="n">seeds</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div></div> <p>最终读取到的seed都保存在<strong>std::vector&lt;KTest *&gt; seeds</strong>中. 然后判断是否有读取到seed</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seeds</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">klee_message</span><span class="p">(</span><span class="s">"KLEE: using %lu seeds</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">seeds</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="c1">// 使用 seed</span>
      <span class="n">interpreter</span><span class="o">-&gt;</span><span class="n">useSeeds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seeds</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <p>既然读取到了seed, 那就<strong>interpreter-&gt;useSeeds(&amp;seeds);</strong>来使用seed. 这之后除了切换目录以及清理seeds的操作, 我们需要重点关注的是<strong>interpreter-&gt;runFunctionAsMain(mainFn, pArgc, pArgv, pEnvp);</strong>. 在interpreter设置好seed后, seed的使用过程会在<strong>runFunctionAsMain</strong>开始.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">RunInDir</span> <span class="o">!=</span> <span class="s">""</span><span class="p">)</span> <span class="p">{...</span> <span class="c1">// 切换目录</span>
    <span class="p">}</span>
    <span class="c1">// 运行main函数</span>
    <span class="n">interpreter</span><span class="o">-&gt;</span><span class="n">runFunctionAsMain</span><span class="p">(</span><span class="n">mainFn</span><span class="p">,</span> <span class="n">pArgc</span><span class="p">,</span> <span class="n">pArgv</span><span class="p">,</span> <span class="n">pEnvp</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">seeds</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>	<span class="c1">// 将seeds里的内容全部释放掉</span>
      <span class="n">kTest_free</span><span class="p">(</span><span class="n">seeds</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
      <span class="n">seeds</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div> <h2 id="useseeds">useSeeds</h2> <p>既然谈到<strong>interpreter-&gt;useSeeds(&amp;seeds);</strong>那就来看看这个<strong>interpreter</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Interpreter</span> <span class="o">*</span><span class="n">interpreter</span> <span class="o">=</span>
    <span class="n">theInterpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">IOpts</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
</code></pre></div></div> <p>这里实例化了一个interpreter. 而该方法的声明是在<strong>interpreter.h</strong>里, 实现却是在<strong>Executor.cpp</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpreter</span> <span class="o">*</span><span class="n">Interpreter</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">InterpreterOptions</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span>
                                 <span class="n">InterpreterHandler</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">new</span> <span class="n">Executor</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>也就是说实际上就是创建了一个Executor实例. 而<strong>Executor</strong>继承自<strong>interpreter类</strong>, 像<strong>useSeeds</strong>和<strong>runFunctionAsMain</strong>都在<strong>Executor类</strong>里进行了定义. 所以<strong>interpreter-&gt;useSeeds(&amp;seeds)</strong>实际上就是<strong>Executor::useSeeds</strong>, <strong>interpreter::runFunctionAsMain</strong>就是<strong>Executor::runFunctionAsMain</strong>. 那么接下来就只看<strong>Executor</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Executor.h</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="n">KTest</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">usingSeeds</span><span class="p">;</span>  
<span class="kt">void</span> <span class="n">useSeeds</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="n">KTest</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">seeds</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
  <span class="n">usingSeeds</span> <span class="o">=</span> <span class="n">seeds</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里将seeds传递给了Executor的私有成员<strong>usingSeeds</strong>. 那么这也就是<strong>interpreter-&gt;useSeeds()</strong>所做的操作了</p> <h2 id="runfunctionasmain">runFunctionAsMain</h2> <p>回顾一下runFunctionAsMain的使用: <strong>interpreter-&gt;runFunctionAsMain(mainFn, pArgc, pArgv, pEnvp);</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Executor</span><span class="o">::</span><span class="n">runFunctionAsMain</span><span class="p">(</span><span class="n">Function</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">arguments</span><span class="p">;</span>

  <span class="c1">// force deterministic initialization of memory objects</span>
  <span class="n">srand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">srandom</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  
  <span class="c1">// MemoryObject 表示分配在某个地址上的对象</span>
  <span class="n">MemoryObject</span> <span class="o">*</span><span class="n">argvMO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">envc</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">envc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">envp</span><span class="p">[</span><span class="n">envc</span><span class="p">];</span> <span class="o">++</span><span class="n">envc</span><span class="p">)</span> <span class="p">;</span>  <span class="c1">// envc表示环境变量的数量</span>

  <span class="kt">unsigned</span> <span class="n">NumPtrBytes</span> <span class="o">=</span> <span class="n">Context</span><span class="o">::</span><span class="n">get</span><span class="p">().</span><span class="n">getPointerWidth</span><span class="p">()</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
  <span class="c1">// 这里f对应的函数为 main, 使用KFunction进行结构化</span>
  <span class="n">KFunction</span> <span class="o">*</span><span class="n">kf</span> <span class="o">=</span> <span class="n">kmodule</span><span class="o">-&gt;</span><span class="n">functionMap</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">kf</span><span class="p">);</span>
  <span class="c1">// 枚举main好参数</span>
  <span class="n">Function</span><span class="o">::</span><span class="n">arg_iterator</span> <span class="n">ai</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">arg_begin</span><span class="p">(),</span> <span class="n">ae</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">arg_end</span><span class="p">();</span>
  <span class="c1">// 为argc个参数和envc个环境变量分配空间</span>
  <span class="p">......</span>
	
  <span class="n">ExecutionState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ExecutionState</span><span class="p">(</span><span class="n">kmodule</span><span class="o">-&gt;</span><span class="n">functionMap</span><span class="p">[</span><span class="n">f</span><span class="p">]);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">pathWriter</span><span class="p">)</span> 
    <span class="c1">// 初始化 记录混合符号执行路径的流 pathOS</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">pathOS</span> <span class="o">=</span> <span class="n">pathWriter</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">symPathWriter</span><span class="p">)</span> 
    <span class="c1">// 初始化 记录单纯符号执行路径的流 pathOS</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">symPathOS</span> <span class="o">=</span> <span class="n">symPathWriter</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">();</span>


  <span class="k">if</span> <span class="p">(</span><span class="n">statsTracker</span><span class="p">)</span>
    <span class="c1">// 记录符号执行时的状态切换, </span>
    <span class="c1">// 参数 parentFrame 为0, 说明是初始状态</span>
    <span class="n">statsTracker</span><span class="o">-&gt;</span><span class="n">framePushed</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">arguments</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">arg_size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">"wrong number of arguments"</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">arg_size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">bindArgument</span><span class="p">(</span><span class="n">kf</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

  <span class="c1">// 将参数用 MemoryObject 和 ObjectState 等类进行封装, 以便klee使用</span>
  <span class="p">......</span> 
      
  <span class="c1">// 初始化了一些state相关的全局变量</span>
  <span class="n">initializeGlobals</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">);</span>

  <span class="c1">// 实例化一个当前进程的进程树</span>
  <span class="n">processTree</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PTree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="c1">// 将当前进程作为进程树的根结点</span>
  <span class="n">state</span><span class="o">-&gt;</span><span class="n">ptreeNode</span> <span class="o">=</span> <span class="n">processTree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
  <span class="n">run</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">);</span>
  <span class="c1">// run(*state)的善后处理</span>
  <span class="n">delete</span> <span class="n">processTree</span><span class="p">;</span>
  <span class="n">processTree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// hack to clear memory objects</span>
  <span class="n">delete</span> <span class="n">memory</span><span class="p">;</span>
  <span class="n">memory</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MemoryManager</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="n">globalObjects</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">globalAddresses</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">statsTracker</span><span class="p">)</span>
    <span class="n">statsTracker</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>我用 <strong>……</strong>省略了在 <strong>runFunctionAsMain</strong> 中有关参数的部分, 以便更加清晰地来看这个函数. <strong>runFunctionAsMain</strong>的前半部分都是在做参数的相关操作, 比如为参数分配空间, 将参数进行封装, 将参数与当前状态绑定之类. 后半部分则是关于<strong>state</strong>的操作, 再为state进行了一些初始化操作后, 使用<strong>run(*state)</strong>来运行状态. 这也是<strong>runFunctionAsMain</strong>里我们的重要关注点.</p> <h2 id="run">run</h2> <p>联系上部分的<strong>interpreter-&gt;useSeeds</strong>, 在设置好<strong>usingSeeds</strong>, 而<strong>usingSeeds</strong>仅在<strong>Executor::run</strong>中使用. 那么我们就直接来分析<strong>run()</strong>来看seed对klee执行流程的影响</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Executor</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">ExecutionState</span> <span class="o">&amp;</span><span class="n">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 对模块中每个函数的每条指令的常数进行处理</span>
  <span class="c1">// 将处理后的结果存储在某个数据结构中</span>
  <span class="n">bindModuleConstants</span><span class="p">();</span>

  <span class="c1">// 初始化计时器</span>
  <span class="n">initTimers</span><span class="p">();</span>
  <span class="c1">// 将初始状态 initialState 添加到 states 这个全局变量中</span>
  <span class="n">states</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initialState</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">usingSeeds</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="c1">// 有传入seed</span>
  <span class="p">}</span>
  <span class="c1">// 创建一个searcher实例</span>
  <span class="n">searcher</span> <span class="o">=</span> <span class="n">constructUserSearcher</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
  <span class="c1">// 初始化searcher操作</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExecutionState</span> <span class="o">*&gt;</span> <span class="n">newStates</span><span class="p">(</span><span class="n">states</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">states</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">searcher</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">newStates</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExecutionState</span> <span class="o">*&gt;</span><span class="p">());</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">states</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">haltExecution</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 通过searcher采取的搜索策略来搜索执行下一个state</span>
    <span class="n">ExecutionState</span> <span class="o">&amp;</span><span class="n">state</span> <span class="o">=</span> <span class="n">searcher</span><span class="o">-&gt;</span><span class="n">selectState</span><span class="p">();</span>
    <span class="c1">// ki是当前指令</span>
    <span class="n">KInstruction</span> <span class="o">*</span><span class="n">ki</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>
    <span class="c1">// 指向下一条指令</span>
    <span class="n">stepInstruction</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
    <span class="c1">// 基于llvm指令集, 对指令字节码进行具体解析并模拟执行</span>
    <span class="n">executeInstruction</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ki</span><span class="p">);</span>
    <span class="c1">// 处理计时器</span>
    <span class="n">processTimers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">MaxInstructionTime</span><span class="p">);</span>
    <span class="c1">// 检查内存使用情况</span>
    <span class="n">checkMemoryUsage</span><span class="p">();</span>
    <span class="c1">// 对states进行更新</span>
    <span class="c1">// 不同的搜索策略, 其更新states的策略不同</span>
    <span class="n">updateStates</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 善后工作</span>
  <span class="n">delete</span> <span class="n">searcher</span><span class="p">;</span>
  <span class="n">searcher</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">doDumpStates</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div> <p>如果没有传入seed, <strong>usingSeeds</strong>为空, 那么<strong>run()</strong>的流程从上到下就是:</p> <ol> <li>对模块中每条指令中的常数进行绑定</li> <li>将初始状态加入到state中</li> <li>创建一个searcher实例并初始化</li> <li>不断循环, 直到state为空 <ul> <li>根据searcher的搜索策略选择下一个要执行的state</li> <li>获取当前指令, 保存为ki, 并将pc指向下一条指令</li> <li>executeInstruction执行当前状态的当前指令</li> <li>处理计时器, 检查内存使用情况, 更新state</li> </ul> </li> <li>清理工作</li> </ol> <p>实际上, 也就是常规符号执行的正常流程. 也就是说这里并没有对seed进行处理. seed也没有影响到这里的常规执行</p> <p>那么我们重点关注的地方就是<strong>usingSeeds</strong>部分</p> <h2 id="usingseeds">usingSeeds</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">usingSeeds</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 获得一个 seedMap[&amp;initialState] 的引用</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">initialState</span><span class="p">];</span>
    <span class="c1">// 通过引用, 将 usingSeeds 里的 seed 内容存进 seedMap[&amp;initialState] 中</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">KTest</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">usingSeeds</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">ie</span> <span class="o">=</span> <span class="n">usingSeeds</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ie</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SeedInfo</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">));</span>

    <span class="c1">// 辅助用的变量 初始化</span>
    <span class="kt">int</span> <span class="n">lastNumSeeds</span> <span class="o">=</span> <span class="n">usingSeeds</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">lastTime</span><span class="p">,</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">lastTime</span> <span class="o">=</span> <span class="n">util</span><span class="o">::</span><span class="n">getWallTime</span><span class="p">();</span>
    <span class="n">ExecutionState</span> <span class="o">*</span><span class="n">lastState</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">seedMap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// 中断</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">haltExecution</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">doDumpStates</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">ExecutionState</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
        <span class="n">seedMap</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">lastState</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
      <span class="n">lastState</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="n">numSeeds</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
      <span class="n">ExecutionState</span> <span class="o">&amp;</span><span class="n">state</span> <span class="o">=</span> <span class="o">*</span><span class="n">lastState</span><span class="p">;</span>
      <span class="c1">// ki是当前指令</span>
      <span class="n">KInstruction</span> <span class="o">*</span><span class="n">ki</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>
      <span class="c1">// 指向下一条指令</span>
      <span class="n">stepInstruction</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
      <span class="c1">// 基于llvm指令集, 对指令字节码进行具体解析并模拟执行</span>
      <span class="n">executeInstruction</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ki</span><span class="p">);</span>
      <span class="c1">// 处理计时器</span>
      <span class="n">processTimers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">MaxInstructionTime</span> <span class="o">*</span> <span class="n">numSeeds</span><span class="p">);</span>
      <span class="c1">// 对states进行更新</span>
      <span class="n">updateStates</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
      
      <span class="c1">// 每执行 1000 条语句 打印一次提示信息</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">stats</span><span class="o">::</span><span class="n">instructions</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{...</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">klee_message</span><span class="p">(</span><span class="s">"seeding done (%d states remain)"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">states</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="c1">// XXX total hack, just because I like non uniform better but want</span>
    <span class="c1">// seed results to be equally weighted.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">ExecutionState</span><span class="o">*&gt;::</span><span class="n">iterator</span>
           <span class="n">it</span> <span class="o">=</span> <span class="n">states</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ie</span> <span class="o">=</span> <span class="n">states</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
         <span class="n">it</span> <span class="o">!=</span> <span class="n">ie</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">OnlySeed</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">doDumpStates</span><span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

</code></pre></div></div> <p>再看<strong>usingSeeds</strong>分支内的语句. 首先通过引用, 将 usingSeeds 里的 seed 内容存进 seedMap[&amp;initialState] 中, 然后初始化了一些辅助变量后, 进入一个循环知道seedMap为空. 那么很显然在这个循环里, 一定对seedMap进行了处理, 不然就是一个死循环了.</p> <p>来看循环里的代码, 跟之前<strong>usingSeeds</strong>以外的常规符号执行流程中, 最明显的区别就是没有用到searcher, 没有用到对应的搜索策略来选择下一个要执行的state. 而是使用的seedMap里各个seed对应的state.</p> <p>那么在这个循环里面, 我们检查了这几个函数. 只有<strong>executeInstruction(state, ki);</strong>有可能包含对seed的操作.</p> <p>因为在执行指令的时候并没有显式地将seedMap作参在执行时使用, 而seedMap是全局变量, 可以随时被调用, 而只需要比对state也能找到处理state时应该对应的seed. 因此我们就来看下整个klee工程里哪里有用到<strong>seedMap</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">branch:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="n">seedMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>        <span class="n">seedMap</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">siit</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">seedMap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
<span class="nl">fork:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="err">¤</span><span class="n">t</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>  <span class="n">bool</span> <span class="n">isSeeding</span> <span class="o">=</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">trueSeeds</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">[</span><span class="n">trueState</span><span class="p">];</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">falseSeeds</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">[</span><span class="n">falseState</span><span class="p">];</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>        <span class="n">seedMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">trueState</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>        <span class="n">seedMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">falseState</span><span class="p">);</span>
<span class="nl">addConstraint:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
<span class="nl">executeGetValue:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>  <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">==</span><span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">updateStates:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="k">if</span> <span class="p">(</span><span class="n">it3</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="n">seedMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it3</span><span class="p">);</span>
        <span class="nl">run:</span>
        <span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">[</span><span class="o">&amp;</span><span class="n">initialState</span><span class="p">];</span>
        <span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">seedMap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>        <span class="n">seedMap</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">lastState</span><span class="p">);</span>
        <span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>        <span class="n">it</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>               <span class="n">it</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ie</span> <span class="o">=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="nl">terminateState:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="k">if</span> <span class="p">(</span><span class="n">it3</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="n">seedMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it3</span><span class="p">);</span>
<span class="nl">terminateStateEarly:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="p">(</span><span class="n">AlwaysOutputSeeds</span> <span class="o">&amp;&amp;</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">)))</span>
<span class="nl">terminateStateOnExit:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="p">(</span><span class="n">AlwaysOutputSeeds</span> <span class="o">&amp;&amp;</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">)))</span>
<span class="nl">executeMakeSymbolic:</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>      <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="n">lib</span><span class="o">/</span><span class="n">Core</span><span class="o">/</span><span class="n">Executor</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// In seed mode we need to add this as a</span>

</code></pre></div></div> <p>总结一下, 有这些函数用到了<strong>seedMap</strong>: <strong>branch</strong>, <strong>fork</strong>, <strong>addConstraint</strong>, <strong>executeGetValue</strong>, <strong>updateStates</strong>, <strong>run</strong>, <strong>terminateState</strong>, <strong>terminateStateEarly</strong>, <strong>terminateStateOnExit</strong>, <strong>executeMakeSymbolic</strong>一共十处</p> <p>那么我们就一个个来看(其中<strong>run</strong>已经分析过, 除外), <strong>seedMap</strong>到底是如何影响klee的执行流程的, 以及<strong>executeInstruction</strong>是通过哪一种方式来操作<strong>seedMap</strong></p> <h2 id="branch">branch</h2> <p>首先明确<strong>Executor::branch</strong>仅在<strong>executeGetValue</strong>和<strong>executeInstruction</strong>的<strong>IndirectBr</strong>和<strong>switch</strong>分支用到.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExecutionState</span><span class="o">*&gt;</span> <span class="n">branches</span><span class="p">;</span>
    <span class="n">branch</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">branches</span><span class="p">);</span>
</code></pre></div></div> <p>作用则是在遇到分支的时候, 判断条件是否满足, 并将对应的条件复制到各自的branches里. 而在<strong>branch</strong>里</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">MaxForks</span><span class="o">!=~</span><span class="mi">0u</span> <span class="o">&amp;&amp;</span> <span class="n">stats</span><span class="o">::</span><span class="n">forks</span> <span class="o">&gt;=</span> <span class="n">MaxForks</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">next</span> <span class="o">=</span> <span class="n">theRNG</span><span class="p">.</span><span class="n">getInt32</span><span class="p">()</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">stats</span><span class="o">::</span><span class="n">forks</span> <span class="o">+=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// XXX do proper balance or keep random?</span>
    <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ExecutionState</span> <span class="o">*</span><span class="n">es</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">theRNG</span><span class="p">.</span><span class="n">getInt32</span><span class="p">()</span> <span class="o">%</span> <span class="n">i</span><span class="p">];</span>
      <span class="n">ExecutionState</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">es</span><span class="o">-&gt;</span><span class="n">branch</span><span class="p">();</span>
      <span class="n">addedStates</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
      <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
      <span class="n">es</span><span class="o">-&gt;</span><span class="n">ptreeNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">PTree</span><span class="o">::</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span><span class="n">PTree</span><span class="o">::</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">res</span> <span class="o">=</span> 
        <span class="n">processTree</span><span class="o">-&gt;</span><span class="n">split</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">ptreeNode</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
      <span class="n">ns</span><span class="o">-&gt;</span><span class="n">ptreeNode</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="n">es</span><span class="o">-&gt;</span><span class="n">ptreeNode</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

</code></pre></div></div> <p>首先会判断是否超出了状态fork的最大数量<strong>MaxForks</strong>, 如果没有超过, 那么就会示例化一个<strong>ExecutionState</strong>对象<strong>es</strong>, 并使用<strong>es-&gt;branch()</strong>来分出对应的分支. 这里的<strong>branch()</strong>的原型是<strong>ExecutionState::branch()</strong>, 就不要混淆了.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ExecutionState</span> <span class="o">*</span><span class="n">ExecutionState</span><span class="o">::</span><span class="n">branch</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">depth</span><span class="o">++</span><span class="p">;</span>

  <span class="n">ExecutionState</span> <span class="o">*</span><span class="n">falseState</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ExecutionState</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
  <span class="n">falseState</span><span class="o">-&gt;</span><span class="n">coveredNew</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">falseState</span><span class="o">-&gt;</span><span class="n">coveredLines</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

  <span class="n">weight</span> <span class="o">*=</span> <span class="p">.</span><span class="mi">5</span><span class="p">;</span>
  <span class="n">falseState</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">-=</span> <span class="n">weight</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">falseState</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>以上是<strong>ExecutionState::branch()</strong>的代码判断. 可以看到这里以当前状态复制了一个<strong>falseState</strong>出来并进行了相关设置, 也就达成了分支所需要的效果.</p> <blockquote> <p>在下一部分的<strong>fork()</strong>中也是使用<strong>branch()</strong>的方法对状态进行分支.</p> </blockquote> <p>然后我们再来看<strong>Executor::branch</strong>中跟seed相关的代码</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 如有必要, 重新分配种子以满足条件 </span>
  <span class="c1">// 必要时根据OnlyReplaySeeds来终止状态 (低效但简单)</span>
  
  <span class="c1">// 返回 state 对应的迭代器 </span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ExecutionState</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="n">seeds</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="n">seedMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>

    <span class="c1">// 假定每个种子仅满足一个条件(当条件互相排斥但结合起来又重言时, 就必然是true)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">siit</span> <span class="o">=</span> <span class="n">seeds</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">siie</span> <span class="o">=</span> <span class="n">seeds</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">siit</span> <span class="o">!=</span> <span class="n">siie</span><span class="p">;</span> <span class="o">++</span><span class="n">siit</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ref</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> 
          <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">siit</span><span class="o">-&gt;</span><span class="n">assignment</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> 
                           <span class="n">res</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="s">"FIXME: Unhandled solver failure"</span><span class="p">);</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">success</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">isTrue</span><span class="p">())</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="c1">// If we didn't find a satisfying condition randomly pick one</span>
      <span class="c1">// (the seed will be patched).</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">N</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">theRNG</span><span class="p">.</span><span class="n">getInt32</span><span class="p">()</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>

      <span class="c1">// Extra check in case we're replaying seeds with a max-fork</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">seedMap</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">siit</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">OnlyReplaySeeds</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">seedMap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
          <span class="n">terminateState</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
          <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> 
    <span class="p">}</span>
  <span class="p">}</span>

</code></pre></div></div> <p>这段代码中重点需要关注的是<strong>solver-&gt;getValue(current, siit-&gt;assignment.evaluate(condition), res);</strong>. 这一句的作用是用来判断我们的seed是否满足相应的condition, 并将结果保存在res里. 如果seed满足<strong>condition</strong>, 那么就直接跳出循环执行seed指定的路径. 最后的<strong>OnlyReplaySeeds</strong>也是用来提前终止那些不包含seed的状态.</p> <h2 id="fork">fork</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ExecutionState</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="err">¤</span><span class="n">t</span><span class="p">);</span>
  <span class="n">bool</span> <span class="n">isSeeding</span> <span class="o">=</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

</code></pre></div></div> <p>首先这里取了一个迭代器<strong>it</strong>以及布尔值<strong>isSeeding</strong>判断当前是否还在seed模式下. 那么我们重点关注迭代器<strong>it</strong>的相关操作</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">isSeeding</span> <span class="o">&amp;&amp;</span> 
      <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">forkDisabled</span> <span class="o">||</span> <span class="n">OnlyReplaySeeds</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
      <span class="n">res</span> <span class="o">==</span> <span class="n">Solver</span><span class="o">::</span><span class="n">Unknown</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">trueSeed</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">falseSeed</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
    <span class="c1">// Is seed extension still ok here?</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">siit</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">siie</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">siit</span> <span class="o">!=</span> <span class="n">siie</span><span class="p">;</span> <span class="o">++</span><span class="n">siit</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ref</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
      <span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> 
        <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">siit</span><span class="o">-&gt;</span><span class="n">assignment</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">res</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="s">"FIXME: Unhandled solver failure"</span><span class="p">);</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">success</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">isTrue</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">trueSeed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">falseSeed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">trueSeed</span> <span class="o">&amp;&amp;</span> <span class="n">falseSeed</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trueSeed</span> <span class="o">&amp;&amp;</span> <span class="n">falseSeed</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// trueSeed和falseSeed至少有1个为假</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">trueSeed</span> <span class="o">||</span> <span class="n">falseSeed</span><span class="p">);</span>	<span class="c1">// trueSeed和falseSeed至少有1个为真</span>
      
      <span class="n">res</span> <span class="o">=</span> <span class="n">trueSeed</span> <span class="o">?</span> <span class="n">Solver</span><span class="o">::</span><span class="n">True</span> <span class="o">:</span> <span class="n">Solver</span><span class="o">::</span><span class="n">False</span><span class="p">;</span>
      <span class="n">addConstraint</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">trueSeed</span> <span class="o">?</span> <span class="n">condition</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">::</span><span class="n">createIsZero</span><span class="p">(</span><span class="n">condition</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

</code></pre></div></div> <p>同样使用<strong>solver-&gt;getValue()</strong>来获取seed与condition的关系, 并将结果保存到<strong>res</strong>里. <strong>res-&gt;isTrue</strong>表明种子满足条件, 为真, 否则不满足条件为假. 当判定seed是trueSeed还是falseSeed后则添加相应的约束. 如果无法判定真假, 则跳出循环</p> <h2 id="addconstraint">addConstraint</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Executor</span><span class="o">::</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">ExecutionState</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConstantExpr</span> <span class="o">*</span><span class="n">CE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CE</span><span class="o">-&gt;</span><span class="n">isTrue</span><span class="p">())</span>
      <span class="n">llvm</span><span class="o">::</span><span class="n">report_fatal_error</span><span class="p">(</span><span class="s">"attempt to add invalid constraint"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Check to see if this constraint violates seeds.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ExecutionState</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">warn</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">siit</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">siie</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">siit</span> <span class="o">!=</span> <span class="n">siie</span><span class="p">;</span> <span class="o">++</span><span class="n">siit</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">bool</span> <span class="n">res</span><span class="p">;</span>
      <span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> 
        <span class="n">solver</span><span class="o">-&gt;</span><span class="n">mustBeFalse</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">siit</span><span class="o">-&gt;</span><span class="n">assignment</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">res</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="s">"FIXME: Unhandled solver failure"</span><span class="p">);</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">success</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">siit</span><span class="o">-&gt;</span><span class="n">patchSeed</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">solver</span><span class="p">);</span>
        <span class="n">warn</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">warn</span><span class="p">)</span>
      <span class="n">klee_warning</span><span class="p">(</span><span class="s">"seeds patched for violating constraint"</span><span class="p">);</span> 
  <span class="p">}</span>

  <span class="n">state</span><span class="p">.</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">condition</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ivcEnabled</span><span class="p">)</span>
    <span class="n">doImpliedValueConcretization</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> 
                                 <span class="n">ConstantExpr</span><span class="o">::</span><span class="n">alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Expr</span><span class="o">::</span><span class="n">Bool</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>在<strong>addConstraint</strong>里, 使用<strong>seedMap</strong>来取得state对应的seed. 并用<strong>solver-&gt;mustBeFalse(state, siit-&gt;assignment.evaluate(condition), res);</strong>判断seed与该condition是否满足永假关系, 也即约束是否跟seed相违背. 如果相违背则<strong>patchSeed</strong>并输出警告信息</p> <h2 id="executegetvalue">executeGetValue</h2> <p><strong>executeGetValue</strong>仅在<strong>SpecialFunctionHandler::handleGetValue</strong>中用到</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">add</span><span class="p">(</span><span class="s">"klee_get_valuef"</span><span class="p">,</span> <span class="n">handleGetValue</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
  <span class="n">add</span><span class="p">(</span><span class="s">"klee_get_valued"</span><span class="p">,</span> <span class="n">handleGetValue</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
  <span class="n">add</span><span class="p">(</span><span class="s">"klee_get_valuel"</span><span class="p">,</span> <span class="n">handleGetValue</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
  <span class="n">add</span><span class="p">(</span><span class="s">"klee_get_valuell"</span><span class="p">,</span> <span class="n">handleGetValue</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
  <span class="n">add</span><span class="p">(</span><span class="s">"klee_get_value_i32"</span><span class="p">,</span> <span class="n">handleGetValue</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
  <span class="n">add</span><span class="p">(</span><span class="s">"klee_get_value_i64"</span><span class="p">,</span> <span class="n">handleGetValue</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
<span class="p">......</span>
<span class="kt">void</span> <span class="n">SpecialFunctionHandler</span><span class="o">::</span><span class="n">handleGetValue</span><span class="p">(</span><span class="n">ExecutionState</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
                                            <span class="n">KInstruction</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
                                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">arguments</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">arguments</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
         <span class="s">"invalid number of arguments to klee_get_value"</span><span class="p">);</span>

  <span class="n">executor</span><span class="p">.</span><span class="n">executeGetValue</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>arguments[0]则是<strong>klee_get_value</strong>的第一个参数. 也就是通过<strong>executeGetValue</strong>来获取对应的符号的值</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Executor</span><span class="o">::</span><span class="n">executeGetValue</span><span class="p">(</span><span class="n">ExecutionState</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
                               <span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">,</span>
                               <span class="n">KInstruction</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">constraints</span><span class="p">.</span><span class="n">simplifyExpr</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ExecutionState</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
    <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">==</span><span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">ref</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="s">"FIXME: Unhandled solver failure"</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">success</span><span class="p">;</span>
    <span class="n">bindLocal</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">siit</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">siie</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">siit</span> <span class="o">!=</span> <span class="n">siie</span><span class="p">;</span> <span class="o">++</span><span class="n">siit</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ref</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span>
      <span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> 
        <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">siit</span><span class="o">-&gt;</span><span class="n">assignment</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">value</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="s">"FIXME: Unhandled solver failure"</span><span class="p">);</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">success</span><span class="p">;</span>
      <span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">conditions</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">vit</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">vie</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">vit</span> <span class="o">!=</span> <span class="n">vie</span><span class="p">;</span> <span class="o">++</span><span class="n">vit</span><span class="p">)</span>
      <span class="n">conditions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">EqExpr</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">vit</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExecutionState</span><span class="o">*&gt;</span> <span class="n">branches</span><span class="p">;</span>
    <span class="n">branch</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">branches</span><span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExecutionState</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">branches</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">ref</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">vit</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">vie</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">vit</span> <span class="o">!=</span> <span class="n">vie</span><span class="p">;</span> <span class="o">++</span><span class="n">vit</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ExecutionState</span> <span class="o">*</span><span class="n">es</span> <span class="o">=</span> <span class="o">*</span><span class="n">bit</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="n">bindLocal</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span> <span class="o">*</span><span class="n">vit</span><span class="p">);</span>
      <span class="o">++</span><span class="n">bit</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>类似, 同<strong>solver-&gt;getValue(state, siit-&gt;assignment.evaluate(e), value);</strong></p> <h2 id="updatestates">updateStates</h2> <p>在<strong>updateStates</strong>里进行的操作是将seedMap里的state给擦除掉.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Executor</span><span class="o">::</span><span class="n">updateStates</span><span class="p">(</span><span class="n">ExecutionState</span> <span class="o">*</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">searcher</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">searcher</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">addedStates</span><span class="p">,</span> <span class="n">removedStates</span><span class="p">);</span>
    <span class="n">searcher</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span> <span class="n">continuedStates</span><span class="p">,</span> <span class="n">pausedStates</span><span class="p">);</span>
    <span class="n">pausedStates</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">continuedStates</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="p">}</span>
  
  <span class="n">states</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">addedStates</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">addedStates</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">addedStates</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

  <span class="c1">// 逐个擦除掉</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ExecutionState</span> <span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">removedStates</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                                               <span class="n">ie</span> <span class="o">=</span> <span class="n">removedStates</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">ie</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ExecutionState</span> <span class="o">*</span><span class="n">es</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">ExecutionState</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">states</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">it2</span><span class="o">!=</span><span class="n">states</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">states</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it2</span><span class="p">);</span>
    <span class="c1">// 在seedMap里擦除掉es</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">ExecutionState</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it3</span> <span class="o">=</span> 
      <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">es</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it3</span> <span class="o">!=</span> <span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
      <span class="n">seedMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it3</span><span class="p">);</span>
    <span class="n">processTree</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">ptreeNode</span><span class="p">);</span>
    <span class="n">delete</span> <span class="n">es</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">removedStates</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>searcher-&gt;update</strong>会将需要擦除的<strong>removedStates</strong>列出来, 然后在循环里将<strong>removeStates</strong>从<strong>states</strong>中擦除, 如果在<strong>seedMap</strong>里有<strong>removedStates</strong>的话, 也一并擦除掉.</p> <h2 id="terminatestate相关">terminateState相关</h2> <p><strong>terminateState</strong>, <strong>terminateState</strong>, <strong>terminateStateOnExit</strong>使用<strong>seedMap</strong>都是对state进行擦除做的清理工作. 因为这个state已经被终结了, 因此会对seedMap进行擦除, 以提高效率</p> <h2 id="executemakesymbolic">executeMakeSymbolic</h2> <p><strong>executeMakeSymbolic</strong>只由<strong>handleMakeSymbolic</strong>一处调用, 而<strong>handleMakeSymbolic</strong>只在处理<strong>klee_make_symbolic</strong>时会起作用.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="s">"klee_make_symbolic"</span><span class="p">,</span> <span class="n">handleMakeSymbolic</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span>
</code></pre></div></div> <p>因此可以确定的是<strong>executeMakeSymbolic</strong>也只有在处理<strong>klee_make_symbolic</strong>时会触发.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Executor</span><span class="o">::</span><span class="n">executeMakeSymbolic</span><span class="p">(</span><span class="n">ExecutionState</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> 
                                   <span class="k">const</span> <span class="n">MemoryObject</span> <span class="o">*</span><span class="n">mo</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Create a new object state for the memory object (instead of a copy).</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replayKTest</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Find a unique name for this array.  First try the original name,</span>
    <span class="c1">// or if that fails try adding a unique identifier.</span>
    <span class="kt">unsigned</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uniqueName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">.</span><span class="n">arrayNames</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">uniqueName</span><span class="p">).</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uniqueName</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"_"</span> <span class="o">+</span> <span class="n">llvm</span><span class="o">::</span><span class="n">utostr</span><span class="p">(</span><span class="o">++</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">Array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="n">arrayCache</span><span class="p">.</span><span class="n">CreateArray</span><span class="p">(</span><span class="n">uniqueName</span><span class="p">,</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="n">bindObjectInState</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>
    <span class="n">state</span><span class="p">.</span><span class="n">addSymbolic</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ExecutionState</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
      <span class="n">seedMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">seedMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// In seed mode we need to add this as a</span>
                             <span class="c1">// binding.</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">siit</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
             <span class="n">siie</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">siit</span> <span class="o">!=</span> <span class="n">siie</span><span class="p">;</span> <span class="o">++</span><span class="n">siit</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SeedInfo</span> <span class="o">&amp;</span><span class="n">si</span> <span class="o">=</span> <span class="o">*</span><span class="n">siit</span><span class="p">;</span>
        <span class="c1">// 如果指定NamedSeedMatching 获取seed中跟mo-&gt;name相同的对象</span>
        <span class="c1">// 否则, 从上至下依次返回mo的对象</span>
        <span class="n">KTestObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">getNextInput</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">NamedSeedMatching</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 没有可取对象</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ZeroSeedExtension</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">values</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">assignment</span><span class="p">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">array</span><span class="p">];</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AllowSeedExtension</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// seed跟内存对象mo的对象数量不一致</span>
            <span class="n">terminateStateOnError</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">"ran out of inputs during seeding"</span><span class="p">,</span>
                                  <span class="n">User</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">numBytes</span> <span class="o">!=</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;&amp;</span>  <span class="c1">// 对象大小不匹配</span>
              <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">AllowSeedExtension</span> <span class="o">||</span> <span class="n">ZeroSeedExtension</span><span class="p">)</span>
                <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">numBytes</span> <span class="o">&lt;</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">||</span> <span class="c1">// obj大小 &lt; mo大小 又不准扩展种子</span>
               <span class="p">(</span><span class="o">!</span><span class="n">AllowSeedTruncation</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">numBytes</span> <span class="o">&gt;</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)))</span> <span class="p">{</span> <span class="c1">// obj大小 &gt; mo大小, 又不准截断种子</span>
               <span class="c1">// 输出错误信息并退出</span>
	    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">msg</span><span class="p">;</span>
	    <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="s">"replace size mismatch: "</span>
		<span class="o">&lt;&lt;</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"["</span> <span class="o">&lt;&lt;</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="s">"]"</span>
		<span class="o">&lt;&lt;</span> <span class="s">" vs "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"["</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">numBytes</span> <span class="o">&lt;&lt;</span> <span class="s">"]"</span>
		<span class="o">&lt;&lt;</span> <span class="s">" in test</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

            <span class="n">terminateStateOnError</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">User</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 开始处理 seed, 进行绑定</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">values</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">assignment</span><span class="p">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">array</span><span class="p">];</span>
            <span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> 
                          <span class="n">obj</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">numBytes</span><span class="p">,</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ZeroSeedExtension</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">numBytes</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">'\0'</span><span class="p">);</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="p">...</span> <span class="c1">// replay ktest 分支</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>在<strong>executeMakeSymbolic</strong>中, 首先会根据<strong>seedMap</strong>提取出所有的<strong>obj</strong>, 并与<strong>mo</strong>进行比较, 如果跟<strong>mo</strong>的大小不匹配, 就会出现一些错误信息. 在真正处理seed时则会将其绑定给<strong>si.assignment.bindings[array]</strong>. 如果没有seed模式. 也就只能执行前半部分</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kt">unsigned</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uniqueName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">.</span><span class="n">arrayNames</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">uniqueName</span><span class="p">).</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uniqueName</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"_"</span> <span class="o">+</span> <span class="n">llvm</span><span class="o">::</span><span class="n">utostr</span><span class="p">(</span><span class="o">++</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">Array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="n">arrayCache</span><span class="p">.</span><span class="n">CreateArray</span><span class="p">(</span><span class="n">uniqueName</span><span class="p">,</span> <span class="n">mo</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="n">bindObjectInState</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>
    <span class="n">state</span><span class="p">.</span><span class="n">addSymbolic</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">array</span><span class="p">);</span>
</code></pre></div></div> <h2 id="seed模式相关选项">Seed模式相关选项</h2> <p>测试使用的命令为:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>klee <span class="nt">-seed-out</span><span class="o">=</span>./klee-out-0/test000002.ktest <span class="nt">-only-seed</span> <span class="nt">-only-replay-seeds</span> get_sign.bc
</code></pre></div></div> <p>测试结果:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>varas@varas-virtual-machine:~/Downloads/klee/examples/get_sign<span class="nv">$ </span>klee <span class="nt">-seed-out</span><span class="o">=</span>./klee-out-0/test000002.ktest <span class="nt">-only-seed</span> <span class="nt">-only-replay-seeds</span> get_sign.bc 
KLEE: output directory is <span class="s2">"/home/varas/Downloads/klee/examples/get_sign/klee-out-6"</span>
KLEE: Using STP solver backend
KLEE: KLEE: using 1 seeds

KLEE: seeding <span class="k">done</span> <span class="o">(</span>0 states remain<span class="o">)</span>

KLEE: <span class="k">done</span>: total instructions <span class="o">=</span> 21
KLEE: <span class="k">done</span>: completed paths <span class="o">=</span> 1
KLEE: <span class="k">done</span>: generated tests <span class="o">=</span> 1
varas@varas-virtual-machine:~/Downloads/klee/examples/get_sign<span class="nv">$ </span><span class="nb">cd </span>klee-out-6/
varas@varas-virtual-machine:~/Downloads/klee/examples/get_sign/klee-out-6<span class="nv">$ </span><span class="nb">ls
</span>assembly.ll  info  messages.txt  run.istats  run.stats  test000001.ktest  warnings.txt
varas@varas-virtual-machine:~/Downloads/klee/examples/get_sign/klee-out-6<span class="nv">$ </span>ktest-tool test000001.ktest 
ktest file : <span class="s1">'test000001.ktest'</span>
args       : <span class="o">[</span><span class="s1">'get_sign.bc'</span><span class="o">]</span>
num objects: 1
object    0: name: <span class="s1">'a'</span>
object    0: size: 4
object    0: data: <span class="s1">'\x01\x01\x01\x01'</span>
varas@varas-virtual-machine:~/Downloads/klee/examples/get_sign/klee-out-6<span class="nv">$ </span>
</code></pre></div></div> <h3 id="-seed-out">-seed-out</h3> <p><strong>-seed-out=</strong>指定的seed文件会保存到<strong>SeedOutFile</strong>中, 在main函数中进行使用.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReplayKTestDir</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">ReplayKTestFile</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="p">...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 指定了 SeedOutFile 读取 seed 内容</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">KTest</span> <span class="o">*&gt;</span> <span class="n">seeds</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span>
           <span class="n">it</span> <span class="o">=</span> <span class="n">SeedOutFile</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ie</span> <span class="o">=</span> <span class="n">SeedOutFile</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
         <span class="n">it</span> <span class="o">!=</span> <span class="n">ie</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">KTest</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">kTest_fromFile</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">());</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">klee_error</span><span class="p">(</span><span class="s">"unable to open: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="c1">// SeedOutFile 方式获取 seed</span>
      <span class="n">seeds</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="p">...</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seeds</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">klee_message</span><span class="p">(</span><span class="s">"KLEE: using %lu seeds</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">seeds</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="c1">// 使用 seed</span>
      <span class="n">interpreter</span><span class="o">-&gt;</span><span class="n">useSeeds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seeds</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RunInDir</span> <span class="o">!=</span> <span class="s">""</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span>
    <span class="p">}</span>
    <span class="c1">// 运行main函数</span>
    <span class="n">interpreter</span><span class="o">-&gt;</span><span class="n">runFunctionAsMain</span><span class="p">(</span><span class="n">mainFn</span><span class="p">,</span> <span class="n">pArgc</span><span class="p">,</span> <span class="n">pArgv</span><span class="p">,</span> <span class="n">pEnvp</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">seeds</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">kTest_free</span><span class="p">(</span><span class="n">seeds</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
      <span class="n">seeds</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="err">}</span>
</code></pre></div></div> <h3 id="-only-seed">-only-seed</h3> <p><strong>-only-seed</strong>与布尔值<strong>OnlySeed</strong>绑定, 默认关闭.</p> <p>描述是<strong>在seed模式结束后, 不做常规搜索直接停止执行</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span>
  <span class="n">OnlySeed</span><span class="p">(</span><span class="s">"only-seed"</span><span class="p">,</span>
	   <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
           <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">"Stop execution after seeding is done without doing regular search (default=off)."</span><span class="p">));</span>
</code></pre></div></div> <p>仅在<strong>Executor:run()</strong>里使用到</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">OnlySeed</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">doDumpStates</span><span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <p>再来看<strong>doDumpStates()</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Executor</span><span class="o">::</span><span class="n">doDumpStates</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DumpStatesOnHalt</span> <span class="o">||</span> <span class="n">states</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">klee_message</span><span class="p">(</span><span class="s">"halting execution, dumping remaining states"</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">state</span> <span class="o">:</span> <span class="n">states</span><span class="p">)</span>
    <span class="n">terminateStateEarly</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="s">"Execution halting."</span><span class="p">);</span>
  <span class="n">updateStates</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>DumpStatesOnHalt</strong>是默认开启的选项, 在退出时将所有活动的状态都dump成测试用例文件.</p> <p>之后的操作是相当于提前终止, 因为<strong>onlySeed</strong>紧接着<strong>seeding done</strong>执行, 因此可以确保在seed模式执行结束后终止其他state</p> <h3 id="-only-replay-seeds">-only-replay-seeds</h3> <p><strong>-only-replay-seed</strong>与布尔值<strong>OnlyReplaySeeds</strong>绑定, 默认关闭.</p> <p>描述是<strong>执行时忽略不含有seed的状态</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span>
  <span class="n">OnlyReplaySeeds</span><span class="p">(</span><span class="s">"only-replay-seeds"</span><span class="p">,</span>
		  <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
                  <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">"Discard states that do not have a seed (default=off)."</span><span class="p">));</span>
</code></pre></div></div> <p>仅在<strong>Executor::branch</strong>和<strong>Executor::fork</strong>有用到</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">OnlyReplaySeeds</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">seedMap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="n">terminateState</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div> <p>手动指定<strong>OnlyReplaySeeds</strong>可以终止状态</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Fix branch in only-replay-seed mode, if we don't have both true</span>
<span class="c1">// and false seeds.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isSeeding</span> <span class="o">&amp;&amp;</span> 
      <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">forkDisabled</span> <span class="o">||</span> <span class="n">OnlyReplaySeeds</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
      <span class="n">res</span> <span class="o">==</span> <span class="n">Solver</span><span class="o">::</span><span class="n">Unknown</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">trueSeed</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="n">falseSeed</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
    <span class="c1">// Is seed extension still ok here?</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SeedInfo</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">siit</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> 
           <span class="n">siie</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">siit</span> <span class="o">!=</span> <span class="n">siie</span><span class="p">;</span> <span class="o">++</span><span class="n">siit</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ref</span><span class="o">&lt;</span><span class="n">ConstantExpr</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
      <span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> 
        <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">siit</span><span class="o">-&gt;</span><span class="n">assignment</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">res</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="s">"FIXME: Unhandled solver failure"</span><span class="p">);</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">success</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">isTrue</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">trueSeed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">falseSeed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">trueSeed</span> <span class="o">&amp;&amp;</span> <span class="n">falseSeed</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trueSeed</span> <span class="o">&amp;&amp;</span> <span class="n">falseSeed</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">trueSeed</span> <span class="o">||</span> <span class="n">falseSeed</span><span class="p">);</span>
      
      <span class="n">res</span> <span class="o">=</span> <span class="n">trueSeed</span> <span class="o">?</span> <span class="n">Solver</span><span class="o">::</span><span class="n">True</span> <span class="o">:</span> <span class="n">Solver</span><span class="o">::</span><span class="n">False</span><span class="p">;</span>
      <span class="n">addConstraint</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">trueSeed</span> <span class="o">?</span> <span class="n">condition</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">::</span><span class="n">createIsZero</span><span class="p">(</span><span class="n">condition</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0" style="text-align: center;"> © Copyright 2025 Song Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script src="/assets/js/zoom.js"></script> <script src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-ER5P9GS1T8"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-ER5P9GS1T8");</script> </body> </html>