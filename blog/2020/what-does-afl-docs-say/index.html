<!DOCTYPE html> <html lang="en"> <head> <meta name="google-site-verification" content="kFTGHTKWYnz7RkFa5Fi4_Tfdijlcl0sWeQbJo40mXOw"/> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Google的AFL仓库文档到底说了什么? | Song Liu</title> <meta name="author" content="Song Liu"/> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@200&display=swap" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/favicon.ico"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://vancir.github.io/blog/2020/what-does-afl-docs-say/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://vancir.github.io/">Song Liu</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" target="_blank" href="/assets/pdf/resume.pdf">Resume</a> </li> <div class="toggle-container"> <a id="light-toggle"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </a> </div> </ul> </div> </div> </nav> </header> <div class="container mt-4"> <div class="post"> <header class="post-header"> <h1 class="post-title">Google的AFL仓库文档到底说了什么?</h1> <p class="post-meta">April 1, 2020</p> <p class="post-tags"> <a href="/blog/2020"> <i class="fas fa-calendar fa-sm"></i> 2020 </a>   ·   <a href="/blog/tag/afl"> <i class="fas fa-hashtag fa-sm"></i> afl</a>   <a href="/blog/tag/fuzzing"> <i class="fas fa-hashtag fa-sm"></i> fuzzing</a>   </p> </header> <article class="post-content"> <h2 id="afl的安装说明">AFL的安装说明</h2> <p>文档给出了<code class="language-plaintext highlighter-rouge">Linux/BSD/MacOS/Solaris/Non-x86 Systems/Others</code>这6个情景下的安装说明. 但是就x86架构而言, 我只想说除开Linux外其他都是邪教. 当然对于其他情景比如非x86架构其实我觉得也是值得一提的(主要是ARM架构, 以Android和一众ARM设备为代表). 什么? 你说我Windows系统就不配拥有姓名吗? 抱歉其实有另一个<code class="language-plaintext highlighter-rouge">WinAFL</code>的项目, 不过那个是基于<code class="language-plaintext highlighter-rouge">DynamoRIO</code>实现的, 暂且不谈.</p> <p>所以接下来我就主要简述这两种情景为主.</p> <h3 id="linux-x86">Linux x86</h3> <p>如果是在Linux的话, 安装简单自然不必多说, 只需要准备好依赖的构建工具(make)和编译器(gcc或clang)即可. 编译器如果选择clang的话, 可以启用LLVM模式, 该模式会有显著的性能提升.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/google/AFL <span class="o">&amp;&amp;</span> <span class="nb">cd </span>AFL
make 
<span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div> <h4 id="llvm模式安装">LLVM模式安装</h4> <p>LLVM模式下的安装需要<code class="language-plaintext highlighter-rouge">clang</code>和<code class="language-plaintext highlighter-rouge">llvm-config</code>工具的支持. 你需要将<code class="language-plaintext highlighter-rouge">llvm-config</code>的位置放在<code class="language-plaintext highlighter-rouge">PATH</code>环境变量里, 或者用<code class="language-plaintext highlighter-rouge">LLVM_CONFIG</code>环境变量指向. 如果LLVM的安装出了困难, 你也可以去官网下载预编译好的二进制文件来使用.</p> <p>设置好环境后进入AFL源码目录下, 只需运行<code class="language-plaintext highlighter-rouge">make</code>即可开始编译. 编译完成会生成<code class="language-plaintext highlighter-rouge">afl-clang-fast</code>和<code class="language-plaintext highlighter-rouge">afl-clang-fast++</code>. 接着你就可以用这两个程序来对第三方的代码进行插桩. 比如像下面这样:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CC</span><span class="o">=</span>/path/to/afl/afl-clang-fast ./configure <span class="o">[</span>...options...]
make
</code></pre></div></div> <p>如果是C++程序的话, 就将<code class="language-plaintext highlighter-rouge">CXX</code>(而非<code class="language-plaintext highlighter-rouge">CC</code>)设置为<code class="language-plaintext highlighter-rouge">afl-clang-fast++</code>即可.</p> <h3 id="非x86架构">非x86架构</h3> <p>非x86架构无法按标准安装步骤进行安装. 但是依然有以下两种方式可供选择:</p> <ol> <li>LLVM模式. LLVM不需要依赖特定的x86指令, 并且十分高效和健壮.</li> <li>QEMU模式. 该模式还可以用于对跨平台的二进制文件进行fuzz, 但是相对更慢和脆弱, 没有源码也能使用.</li> </ol> <p>如果在有源码的条件下推荐使用LLVM模式. 使用如下命令编译AFL:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">AFL_NO_X86</span><span class="o">=</span>1 gmake <span class="o">&amp;&amp;</span> gmake <span class="nt">-C</span> llvm_mode
</code></pre></div></div> <p>并使用<code class="language-plaintext highlighter-rouge">afl-clang-fast</code>或<code class="language-plaintext highlighter-rouge">afl-clang-fast++</code>来编译你的测试目标程序.</p> <h2 id="快速使用">快速使用</h2> <p>编译安装好<code class="language-plaintext highlighter-rouge">AFL</code>后, 就可以以一个小的使用demo来快速上手这个工具了. 以下都是针对于有源码的目标程序进行插桩和fuzz:</p> <ol> <li>使用<code class="language-plaintext highlighter-rouge">afl-gcc</code>(或其他的afl工具)来编译目标程序(插桩用). 常见的方式如下: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="nv">CC</span><span class="o">=</span>/path/to/afl-gcc <span class="nv">CXX</span><span class="o">=</span>/path/to/afl-g++ ./configure <span class="nt">--disable-shared</span>
 make
</code></pre></div> </div> </li> <li>创建一个精简有效的输入样例. 如果输入有指定的格式要求(比如SQL/HTTP等), AFL也提供了方式创建字典进行描述, 但这里是快速使用的阶段, 我们大致了解使用流程为紧, 后续内容再详细描述.</li> <li>如果程序的输入是通过<code class="language-plaintext highlighter-rouge">stdin</code>来读取, 那么可以用以下方式来运行: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> ./afl-fuzz <span class="nt">-i</span> testcase_dir <span class="nt">-o</span> findings_dir <span class="nt">--</span> <span class="se">\</span>
     /path/to/tested/program <span class="o">[</span>...program<span class="s1">'s cmdline...]
</span></code></pre></div> </div> </li> <li>如果程序输入是通过<code class="language-plaintext highlighter-rouge">文件</code>进行读取, 那么也只需要在上述命令后面添加<code class="language-plaintext highlighter-rouge">@@</code>即可. AFL会帮你填上自动生成文件的路径名.</li> <li>然后就静观AFL的数据看板跑跑跑就可以啦!</li> </ol> <h2 id="状态看板">状态看板</h2> <p>以下是一个AFL模糊测试过程中的状态看板:</p> <figure> <picture> <source media="(max-width: 480px)" srcset="https://i.loli.net/2020/10/25/n2lhwZR1HOrWYUN-480.webp"></source> <source media="(max-width: 800px)" srcset="https://i.loli.net/2020/10/25/n2lhwZR1HOrWYUN-800.webp"></source> <source media="(max-width: 1400px)" srcset="https://i.loli.net/2020/10/25/n2lhwZR1HOrWYUN-1400.webp"></source> <img class="img-fluid rounded " src="https://i.loli.net/2020/10/25/n2lhwZR1HOrWYUN.png" height="230" style="display:block;margin:0 auto;" data-zoomable=""> </picture> </figure> <p>数据看板有很好地颜色来区分重要等级, 看板也有不同的小的板块组成, 那么接下来就来讲讲各个板块.</p> <ol> <li> <code class="language-plaintext highlighter-rouge">Process timing</code>: 就是一个时间统计的板块. 不过需要注意的是, 如果在刚开始fuzz有一小会之后, 还是没有fuzz出新的路径的话, 那么很有可能是目标程序没有被正确地运行起来. 可能的原因是没能正确地解析输入, 另一个就是给定的内存太少, 程序无法载入内存.</li> <li> <code class="language-plaintext highlighter-rouge">Overall results</code>: 显示fuzzer目前总计进行的论数, fuzz出了多少有趣的测试用例, 有多少各异的崩溃. 需要注意的是<code class="language-plaintext highlighter-rouge">cycles done</code>的颜色: 它在最初是洋红色, 随后如果有新发现就会变成黄色, 蓝色以此类推. 直到很长时间没有新发现了才会变成<code class="language-plaintext highlighter-rouge">绿色</code> </li> <li> <code class="language-plaintext highlighter-rouge">Cycle progress</code>: 显示当前的测试用例ID以及超时的路径数量. 有时会在第一行显示<code class="language-plaintext highlighter-rouge">*</code>后缀表明该当前处理的路径不是<code class="language-plaintext highlighter-rouge">首选</code>的.</li> <li> <code class="language-plaintext highlighter-rouge">Map coverage</code>: 提供覆盖率情况. <code class="language-plaintext highlighter-rouge">map density</code>指示目前已经命中多少分支元组.</li> <li> <code class="language-plaintext highlighter-rouge">Stage progress</code>: 这个板块能告知fuzzer目前正处在的阶段. fuzzer的阶段有以下几种: <ol> <li> <code class="language-plaintext highlighter-rouge">calibration</code>校验: 在模糊测试前进行的阶段, 检查执行路径以发现异常, 评估基准速度等.</li> <li> <code class="language-plaintext highlighter-rouge">trim L/S</code>: 另一个预准备阶段, 测试用例会被裁剪为同效的最简形式.</li> <li> <code class="language-plaintext highlighter-rouge">bitflip L/S</code>: 比特翻转. 在任意时间翻转L个比特, S个比特的步长遍历输入文件.</li> <li> <code class="language-plaintext highlighter-rouge">arith L/8</code>: 算数操作. fuzzer对<code class="language-plaintext highlighter-rouge">8/16/32</code>比特的数值加减某个小整数.</li> <li> <code class="language-plaintext highlighter-rouge">extras</code>: 填充字典项. fuzzer根据是使用用户提供的字典(-x)还是自动创建的字典, 来显示为”user”或”auto”. 如果是覆写数据则是”over”, 插入数据则是”insert”.</li> <li> <code class="language-plaintext highlighter-rouge">havoc</code>: 随机调整. 该阶段会进行包括比特翻转, 使用”随机有趣”证书进行覆写, 块删除, 块复制, 字典等各种操作.</li> <li> <code class="language-plaintext highlighter-rouge">splice</code>: 在任意选择的中点将队列中的两个随机输入拼接在一起.</li> <li> <code class="language-plaintext highlighter-rouge">sync</code>: 只在并行fuzz时出现, 该阶段会同步其他fuzzer的状态信息.</li> </ol> </li> <li> <code class="language-plaintext highlighter-rouge">Findings in depth</code>: 显示一些度量标准, 比如有趣的路径数量, 新发现的边数量, crash总数等.</li> <li> <code class="language-plaintext highlighter-rouge">Fuzzing strategy yields</code>: 模糊测试的度量信息.</li> <li> <code class="language-plaintext highlighter-rouge">Path geometry</code>: <ul> <li> <code class="language-plaintext highlighter-rouge">levels</code>: 表示导向型fuzzing过程所到达的路径深度, 路径越深表明该导向的价值越高.</li> <li> <code class="language-plaintext highlighter-rouge">pending</code>: 表示尚未经过任何模糊处理的输入的数量.</li> <li> <code class="language-plaintext highlighter-rouge">pend fav</code>: 表示fuzzer认为队列中可能有趣的输入数量.</li> <li> <code class="language-plaintext highlighter-rouge">own finds</code>: 表示模糊过程发现的新路径数量.</li> <li> <code class="language-plaintext highlighter-rouge">imported</code>: 表示并行fuzz过程中从其他fuzzer中导入的新路径数量.</li> <li> <code class="language-plaintext highlighter-rouge">stability</code>: 表示相同输入在目标程序中产生可变行为的程度, 这可以表明观察到的行为的一致性. 如果该数值较低, 就表明行为的不确定性, AFL也很难区分对输入文件变异带来的影响.</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">CPU load</code>: 显示CPU的利用率.</li> </ol> <h2 id="qemu模式">QEMU模式</h2> <p>QEMU模式是AFL能进行黑盒模糊测试的关键, 在无法获取源码使用<code class="language-plaintext highlighter-rouge">afl-gcc</code>构建的时候, 就需要<code class="language-plaintext highlighter-rouge">QEMU</code>这样的全平台模拟工具来运行二进制文件和测试. 不过全平台模拟带来的开销也是可怕的(2到5倍的性能开销, 但也好过<code class="language-plaintext highlighter-rouge">DynamoRIO</code>和<code class="language-plaintext highlighter-rouge">PIN</code>).</p> <p>启用该模式需要对QEMU源码进行补丁, AFL选用的QEMU版本为<code class="language-plaintext highlighter-rouge">2.10.0</code>, 并提供了脚本<code class="language-plaintext highlighter-rouge">qemu_mode/build_qemu_support.sh</code>下载/配置/编译QEMU工具. 一旦安装完成, 即可通过<code class="language-plaintext highlighter-rouge">afl-fuzz</code>使用<code class="language-plaintext highlighter-rouge">-Q</code>选项启用QEMU模式.</p> <p>当然QEMU是平台无关的, 因此你可以在运行<code class="language-plaintext highlighter-rouge">build_qemu_support.sh</code>之前设置<code class="language-plaintext highlighter-rouge">CPU_TARGET</code>环境变量以构建特定架构的QEMU支持. 比如<code class="language-plaintext highlighter-rouge">CPU_TARGET=arm</code></p> <p>插桩过程仅针对链接过程中遇到的第一个ELF文件的<code class="language-plaintext highlighter-rouge">.text</code>代码段, 故而<code class="language-plaintext highlighter-rouge">afl-fuzz</code>不会去跟踪共享库文件, 也就是说:</p> <ol> <li>你要分析的任何库文件, 都必须以静态链接的方式编入ELF文件中去. 不过好在大部分的闭源程序都会这样干.</li> <li>标准C库和其他不必关系的库应该动态链接的方式加载, 否则AFL将不可避免在此处产生开销.</li> </ol> <p>设置<code class="language-plaintext highlighter-rouge">AFL_INST_LIBS=1</code>可以用来绕过<code class="language-plaintext highlighter-rouge">.text</code>检测逻辑, 进而检测遇到的每个基本块.</p> <h3 id="坑点">坑点</h3> <ol> <li>如果目标程序带有文件校验, 插桩会改动文件本身, 那么你需要修复文件的校验或者移除相应的校验代码.</li> <li>不要将QEMU和<code class="language-plaintext highlighter-rouge">ASAN/MSAN</code>或类似技术混用起来, 因此QEMU不兼容这些sanitizer的<code class="language-plaintext highlighter-rouge">Shadow VM</code>技术, 混用会使得QEMU占光内存.</li> <li>QEMU不能确保安全性, 对于不可信的二进制需要先在沙箱和杀软运行一遍.</li> </ol> <h3 id="二进制重写">二进制重写</h3> <p>在QEMU模拟执行前重写二进制, 在汇编代码内写入插桩代码, 能使得运行更快性能更高. 但是目前的二进制重写困难重重, 它需要正确且完整地重新建模程序的控制流, 所以这是一个可以努力的方向. 如果你想尝试的话, 也可以试试 <a href="https://github.com/vrtadmin/moflow/tree/master/afl-dyninst" target="_blank" rel="noopener noreferrer">afl-dyninst</a>.</p> <h2 id="性能优化要点">性能优化要点</h2> <h3 id="01-精简测试样例">01 精简测试样例</h3> <p>大型的测试样例会使得fuzz的整体效率大打折扣, 尽量地精简测试样例. 如果你实在是需要使用大型, 第三方的语料库作为输入, 那么请使用<code class="language-plaintext highlighter-rouge">afl-cmin</code>并设置适当的超时限制.</p> <h3 id="02-选择小型目标">02 选择小型目标</h3> <p>选择目标时尽量选择小型的目标. 比如两个程序功能相近, 优先选择小型目标能带来显著的性能提升.</p> <h3 id="03-使用llvm模式">03 使用LLVM模式</h3> <p>使用LLVM模式可以带来2倍的性能提升. 同时LLVM还提供了一种<code class="language-plaintext highlighter-rouge">持久进程内fuzz</code>的模式, 对于特定的自包含库文件可以提升5-10倍的性能. 而对于启动开销大的目标程序, 则提供了<code class="language-plaintext highlighter-rouge">延迟启动fork server</code>的模式可以带来提升. 这两种模式都仅需编辑少数一两行策略代码即可启用.</p> <h3 id="04-剖析优化目标">04 剖析优化目标</h3> <p>确认目标在编译时是否有能提高性能的选项或设置. 如果检查过选项后还是很慢, 可以通过<code class="language-plaintext highlighter-rouge">strace -tt</code>或类似的方法去检查二进制文件是否在做一些笨拙的事. 有时你可以单单将配置文件指定为<code class="language-plaintext highlighter-rouge">/dev/null</code>, 或者关闭一些对测试无关的功能, 就可以显著地提升性能. 常见的资源消耗大多是<code class="language-plaintext highlighter-rouge">exec*()</code>, <code class="language-plaintext highlighter-rouge">popen()</code>, <code class="language-plaintext highlighter-rouge">system()</code>, <code class="language-plaintext highlighter-rouge">sleep()</code>或类似的调用带来的.</p> <p>测试时可以暂时关闭<code class="language-plaintext highlighter-rouge">ASAN</code>, 只在手动检查生成的语料库的时候单独拿一个启用了ASAN的二进制文件进行测试.</p> <h3 id="05-缩减插桩范围">05 缩减插桩范围</h3> <p>只针对你需要进行fuzz的功能/库文件进行插桩, 而在不必要fuzz的部分使用正常未插桩的二进制文件即可.</p> <h3 id="06-并行fuzz">06 并行fuzz</h3> <p>AFL是为单核处理单任务设计的, 但是在多核机器上完全可以将fuzz任务并发运行. <code class="language-plaintext highlighter-rouge">afl-gotcpu</code>可以帮助测量空闲的CPU情况.</p> <h3 id="07-限制内存和超时">07 限制内存和超时</h3> <p>在合理的区间内, 使用少的内存和超时能确保测试能更有效地进行, 而避免一些畸形输入占用和花费大量的时间和内存.</p> <h3 id="08-检查系统配置">08 检查系统配置</h3> <ol> <li>系统负载. 尽量关闭不必要的程序占用CPU.</li> <li>磁盘读写. fuzzer会频繁读写访问磁盘文件.</li> <li> <p>CPU性能模式. Linux默认”按需”调整CPU的性能, 你可以用以下方式将CPU设置为性能模式:</p> <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="nb">cd</span> /sys/devices/system/cpu
 <span class="nb">echo </span>performance | <span class="nb">tee </span>cpu<span class="k">*</span>/cpufreq/scaling_governor
</code></pre></div> </div> </li> <li>透明大页. 一些内存分配器会启用透明大页, 这会严重降低fuzz性能. 可以使用<code class="language-plaintext highlighter-rouge">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>进行关闭.</li> <li> <p>任务调度策略. 不同策略带来的提升也不一样, 通常<code class="language-plaintext highlighter-rouge">SCHED_RR</code>能带来提升. 按以下方式设置:</p> <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="nb">echo </span>1 <span class="o">&gt;</span>/proc/sys/kernel/sched_child_runs_first
 <span class="nb">echo </span>1 <span class="o">&gt;</span>/proc/sys/kernel/sched_autogroup_enabled
</code></pre></div> </div> </li> </ol> <h3 id="09-还是不行试试-d">09 还是不行?试试-d</h3> <p>如果还是不给力, 那么就使用<code class="language-plaintext highlighter-rouge">-d</code>选项, 这样能跳过所有的确定性模糊测试步骤, 虽然这会使得测试不够深入.</p> <h2 id="并行fuzz">并行Fuzz</h2> <p>单个<code class="language-plaintext highlighter-rouge">afl-fuzz</code>只会占用1个CPU, 因此在多核系统下可以同时进行多个fuzz任务. 如果只是针对多个不相关的二进制进行fuzz的话, 只需要运行多个<code class="language-plaintext highlighter-rouge">afl-fuzz</code>程序即可, 但如果想针对同一个目标的话, fuzz的信息需要共享给其他的<code class="language-plaintext highlighter-rouge">afl-fuzz</code>实例.</p> <h3 id="单系统并行">单系统并行</h3> <p>如果是在单个机器上对单个目标进行并发fuzz, 那么只需要创建一个所有<code class="language-plaintext highlighter-rouge">afl-fuzz</code>可用的共享文件夹, 然后指定每一个<code class="language-plaintext highlighter-rouge">afl-fuzz</code>实例命名即可.</p> <p>比如运行第一个实例:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./afl-fuzz <span class="nt">-i</span> testcase_dir <span class="nt">-o</span> sync_dir <span class="nt">-M</span> fuzzer01 <span class="o">[</span>...other stuff...]
</code></pre></div></div> <p>然后类似地创建接二连三的实例:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./afl-fuzz <span class="nt">-i</span> testcase_dir <span class="nt">-o</span> sync_dir <span class="nt">-S</span> fuzzer02 <span class="o">[</span>...other stuff...]
./afl-fuzz <span class="nt">-i</span> testcase_dir <span class="nt">-o</span> sync_dir <span class="nt">-S</span> fuzzer03 <span class="o">[</span>...other stuff...]
</code></pre></div></div> <p>而每个实例会将它的状态单独保存在分隔的子文件夹内, 类似<code class="language-plaintext highlighter-rouge">/path/to/sync_dir/fuzzer01/</code>这样. 每个实例会周期性地扫描共享目录内的测试样例, 对于感兴趣的测试用例就会加入到自身的fuzz过程. <code class="language-plaintext highlighter-rouge">-M</code>是指定<code class="language-plaintext highlighter-rouge">master</code>, 而<code class="language-plaintext highlighter-rouge">-S</code>是指定<code class="language-plaintext highlighter-rouge">slave</code>. 主从实例的区别在于主实例会执行确定性检查, 而仆实例只进行随机调整.</p> <p>当然如果你也可以用<code class="language-plaintext highlighter-rouge">-S</code>来运行所有实例也没关系, 对于非常慢/复杂的目标这样做常常效果不错. 但是如果你想运行多个主实例的话, 那么就会带来巨大的资源浪费. 并且需要像以下这样运行<code class="language-plaintext highlighter-rouge">afl-fuzz</code>实例.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./afl-fuzz <span class="nt">-i</span> testcase_dir <span class="nt">-o</span> sync_dir <span class="nt">-M</span> masterA:1/3 <span class="o">[</span>...]
./afl-fuzz <span class="nt">-i</span> testcase_dir <span class="nt">-o</span> sync_dir <span class="nt">-M</span> masterB:2/3 <span class="o">[</span>...]
./afl-fuzz <span class="nt">-i</span> testcase_dir <span class="nt">-o</span> sync_dir <span class="nt">-M</span> masterC:3/3 <span class="o">[</span>...]
</code></pre></div></div> <p>AFL还提供了<code class="language-plaintext highlighter-rouge">afl-whatsup</code>工具用来监视各个任务的进展情况. 不过还有一点要注意: 如果你在并发时使用<code class="language-plaintext highlighter-rouge">-f</code>指定输入文件的话, 需要确保文件相互独立. 不过要是你用<code class="language-plaintext highlighter-rouge">@@</code>不带<code class="language-plaintext highlighter-rouge">-f</code>的话就不会有这样的问题.</p> <h3 id="多系统并行">多系统并行</h3> <p>多系统并行和单系统类似, 关键区别在于需要额外编写一个简单脚本, 执行以下两个动作来同步各个fuzz实例的状态:</p> <ol> <li> <p>使用SSH在机器之间同步共享文件夹内的状态文件.</p> <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="k">for </span>s <span class="k">in</span> <span class="o">{</span>1..10<span class="o">}</span><span class="p">;</span> <span class="k">do
     </span>ssh user@host<span class="k">${</span><span class="nv">s</span><span class="k">}</span> <span class="s2">"tar -czf - sync/host</span><span class="k">${</span><span class="nv">s</span><span class="k">}</span><span class="s2">_fuzzid*/[qf]*"</span> <span class="o">&gt;</span>host<span class="k">${</span><span class="nv">s</span><span class="k">}</span>.tgz
 <span class="k">done</span>
</code></pre></div> </div> </li> <li> <p>在剩余机器之间分发状态文件.</p> <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="k">for </span>s <span class="k">in</span> <span class="o">{</span>1..10<span class="o">}</span><span class="p">;</span> <span class="k">do
     for </span>d <span class="k">in</span> <span class="o">{</span>1..10<span class="o">}</span><span class="p">;</span> <span class="k">do
         </span><span class="nb">test</span> <span class="s2">"</span><span class="nv">$s</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"</span><span class="nv">$d</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="k">continue
         </span>ssh user@host<span class="k">${</span><span class="nv">d</span><span class="k">}</span> <span class="s1">'tar -kxzf -'</span> &lt;host<span class="k">${</span><span class="nv">s</span><span class="k">}</span>.tgz
     <span class="k">done
 done</span>
</code></pre></div> </div> </li> </ol> <p>示例可以参考<code class="language-plaintext highlighter-rouge">experimental/distributed_fuzzing/</code>下的脚本, 或者还有另一个具有特色的实验性工具 <a href="https://github.com/MartijnB/disfuzz-afl" target="_blank" rel="noopener noreferrer">disfuzz-afl</a>, 以及另一种客户端-服务端实现 <a href="https://github.com/richo/roving" target="_blank" rel="noopener noreferrer">roving</a>.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0" style="text-align: center;"> © Copyright 2025 Song Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script src="/assets/js/zoom.js"></script> <script src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-ER5P9GS1T8"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-ER5P9GS1T8");</script> </body> </html>