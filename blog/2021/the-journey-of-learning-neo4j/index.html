<!DOCTYPE html> <html lang="en"> <head> <meta name="google-site-verification" content="kFTGHTKWYnz7RkFa5Fi4_Tfdijlcl0sWeQbJo40mXOw"/> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>我在学习和实践图数据库 Neo4j 的漫漫成长路 | Song Liu</title> <meta name="author" content="Song Liu"/> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@200&display=swap" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/favicon.ico"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://vancir.github.io/blog/2021/the-journey-of-learning-neo4j/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://vancir.github.io/">Song Liu</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" target="_blank" href="/assets/pdf/resume.pdf">Resume</a> </li> <div class="toggle-container"> <a id="light-toggle"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </a> </div> </ul> </div> </div> </nav> </header> <div class="container mt-4"> <div class="post"> <header class="post-header"> <h1 class="post-title">我在学习和实践图数据库 Neo4j 的漫漫成长路</h1> <p class="post-meta">February 11, 2021</p> <p class="post-tags"> <a href="/blog/2021"> <i class="fas fa-calendar fa-sm"></i> 2021 </a>   ·   <a href="/blog/tag/neo4j"> <i class="fas fa-hashtag fa-sm"></i> neo4j</a>   <a href="/blog/tag/optimization"> <i class="fas fa-hashtag fa-sm"></i> optimization</a>   </p> </header> <article class="post-content"> <h2 id="什么是图数据库和neo4j">什么是图数据库和Neo4j?</h2> <p>传统关系型数据库通过文档字段来建立数据的关联, 但是这并不利于海量数据背景下的关系推导. 图数据库应运而生, 图数据库的上层就是我们熟悉的图网络结构, 而下层则是对图结构进行了性能优化, 使之能进行快速的关系推导. 图数据库在知识图谱(比如社交关系推导)和图神经网络(GNN)上有很大的应用.</p> <p><a href="https://github.com/neo4j/neo4j" target="_blank" rel="noopener noreferrer">Neo4j</a>是业界主流的图数据库, 数据库目前排名是19(参见<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener noreferrer">DB-Engines Ranking</a>), 以点/关系进行存储, 支持百亿级别的查询. Neo4j分为免费的社区版和付费的企业版. 社区版只能进行单机部署, 企业版可以部署集群且性能上有着诸多优化, 以及解锁了诸多限制. <a href="https://github.com/graphfoundation/ongdb" target="_blank" rel="noopener noreferrer">ONgDB</a> 是Neo4j付费闭源前的分支版本, 目前的最新版本为3.6.2, 跟Neo4j企业版本3.6功能相差无几.</p> <h2 id="ongdb因果集群部署">ONgDB因果集群部署</h2> <p>因果集群基于Raft协议开发, Raft是一种更加易于理解的一致性算法, 可支持大规模和多拓扑结构的数据环境. 因果集群主要有以下两大特点:</p> <ol> <li> <p>安全性：核心服务器(Core)为事物平台处理提供了容错平台</p> </li> <li> <p>可扩展性：只读副本(Read Replica)为图查询提供了一个大规模高可扩展的平台</p> </li> </ol> <p>集群部署会有一些坑点，也许是版本迭代升级出现的新问题，从网上搜集的现有资料并没有提及到这些问题和解决方法。</p> <p>首先我的使用的版本是<code class="language-plaintext highlighter-rouge">ongdb-enterprise-3.6.2</code>，这是我之前就下载好存本地的，但此时在ONgDB仓库里将之前发布的版本都删除了（我推测是因为跟Neo4j打官司的原因），只留下约一个月前发布的<a href="https://github.com/graphfoundation/ongdb/releases/tag/1.0.0-alpha01" target="_blank" rel="noopener noreferrer">1.0.0-alpha01</a>版本，这也是ONgDB正式发布的第一个alpha测试版本，原先虽然名为ONgDB但其实代码里面都是以neo4j来命名，而这个<code class="language-plaintext highlighter-rouge">1.0.0</code>则将名称都改为了ongdb。并且ongdb和neo4j在配置上也并不完全一致，比如因果集群部分配置就是这样。我在使用1.0.0版本进行部署的时候主节点会卡在<code class="language-plaintext highlighter-rouge">Attempting to connect to the other cluster members</code>阶段，而ONgDB的文档内容非常少且网站也挂了，确认我配置没有问题后，我选择切回了旧的<code class="language-plaintext highlighter-rouge">ongdb-enterprise-3.6.2</code>版本。（并且此时ongdb-apoc还不兼容1.0.0版本）</p> <p>我测试使用的是三台服务器，需要先配置好SSH密钥，让这三台服务器能通过SSH直接登录到彼此服务器。</p> <p>随后参考Neo4j的集群配置文档，为配置文件<code class="language-plaintext highlighter-rouge">conf/neo4j.conf</code>改动以下内容（注意：尽量去找配置文件内已有的项进行修改，而不是直接在文件末尾新增，因为多个相同项Neo4j只取第一项作为结果）：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dbms.default_listen_address<span class="o">=</span>0.0.0.0
<span class="c"># 其他服务器用该地址来连接到节点，设定为节点的IP即可（无需端口）</span>
dbms.default_advertised_address<span class="o">=</span>core03.example.com
<span class="c"># 指定节点是核心节点还是冗余节点</span>
dbms.mode<span class="o">=</span>CORE
<span class="c"># 集群内所有节点的地址，集群节点启动后会不断通过该列表探测活跃的成员，默认端口5000</span>
causal_clustering.initial_discovery_members<span class="o">=</span>core01.example.com:5000,core02.example.com:5000,core03.example.com:5000
<span class="c"># （可选）该选项能避免集群在选举新的主节点前预先选举候选节点，这样就能避免因网络原因无法选举</span>
causal_clustering.enable_pre_voting<span class="o">=</span><span class="nb">true</span>
</code></pre></div></div> <p>所有节点的配置上其实除了<code class="language-plaintext highlighter-rouge">dbms.default_advertised_address</code>需要设置为自己的IP地址外，其他的配置都是一致的（当然还有mode你可以自己选定是作为核心节点还是冗余节点）。</p> <p>配置完后逐个启动各个节点即可，如果没有成功启动，那么很有可能是数据不一致带来的问题，建议先将<code class="language-plaintext highlighter-rouge">data</code>清空或重命名其他名称，保证集群内各节点的<code class="language-plaintext highlighter-rouge">data</code>都是一致的，重新启动图数据库。</p> <p><strong>一些报错信息及解决办法</strong></p> <ul> <li> <code class="language-plaintext highlighter-rouge">Waiting to hear from leader</code>： 清空<code class="language-plaintext highlighter-rouge">data</code>或者重命名成其他名称</li> <li> <code class="language-plaintext highlighter-rouge">Unable to find transaction 1 in any of my logical logs</code>： 数据不一致造成的问题，可以尝试清空<code class="language-plaintext highlighter-rouge">data</code>或者<code class="language-plaintext highlighter-rouge">neo4j-admin unbind --database=graph.db</code> </li> <li>对于因果集群要想使用neo4j-import导入全量数据，也会存在数据不一致造成启动失败的问题，所以官方给出的实践方案是，在一个节点上成功导入数据后，使用scp或rsync等工具直接导入的数据库传输到集群内其他节点服务器上。当然如果依然有报错情况的话，还需要执行<code class="language-plaintext highlighter-rouge">neo4j-admin unbind --database=graph.db</code>来解除绑定。</li> </ul> <p>集群成功部署后，就可以通过<code class="language-plaintext highlighter-rouge">call dbms.cluster.overview()</code>和<code class="language-plaintext highlighter-rouge">call dbms.cluster.routing.getServers()</code>来查看集群成员角色和请求路由信息。默认第一个启动的节点为作为主节点，其他节点则作为从节点。主节点负责协调集群并接受所有的写入，数据改动会同步到所有从节点上，主节点挂掉则其他从节点就会开始进行选举，投票出新的节点来作为主节点进行服务，集群在可用性上有很大的强化。</p> <p>集群的连接方式基本也没有多少变化，原先单实例时的协议头为<code class="language-plaintext highlighter-rouge">bolt://</code>，而启用了路由的协议头则变更为<code class="language-plaintext highlighter-rouge">bolt+routing://</code>，协议头后面跟任意集群内节点的地址即可。当然集群内各节点也依然可以使用<code class="language-plaintext highlighter-rouge">bolt://</code>协议头单独用来查询数据（注意可读不一定可写）。另外要注意自己使用的驱动是否支持直接使用<code class="language-plaintext highlighter-rouge">bolt+routing://</code>协议头，像py2neo就不支持直接改协议头，但是可以在初始化Graph对象时增加<code class="language-plaintext highlighter-rouge">routing=True</code>选项启用路由模式。</p> <h2 id="关于性能优化的技巧">关于性能优化的技巧</h2> <ul> <li> <p>图数据库配置<code class="language-plaintext highlighter-rouge">conf/neo4j.con</code>, 可以使用<code class="language-plaintext highlighter-rouge">bin/neo4j-admin memrec</code>来查看推荐的配置.</p> <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c"># 堆内存</span>
dbms.memory.heap.initial_size<span class="o">=</span>16384m
dbms.memory.heap.max_size<span class="o">=</span>16384m
<span class="c"># 页面缓存</span>
dbms.memory.pagecache.size<span class="o">=</span>80g
</code></pre></div> </div> </li> <li> <p>创建索引来提高检索速度: <code class="language-plaintext highlighter-rouge">create index on :Person(firstname)</code>, 使用<code class="language-plaintext highlighter-rouge">:schema</code>可以确认索引状态, 索引状态为ONLINE则表示索引已经生效.</p> </li> <li> <p>数据预热: 预先进行全图的查询来将图数据载入到缓存里, 来加快检索速度.如<code class="language-plaintext highlighter-rouge">call apoc.warmup.run()</code>和<code class="language-plaintext highlighter-rouge">match (n) optional match (n)-[r]-&gt;() return count(n) + count(r)</code></p> </li> <li> <p>根据情况将不同类型不同场景的数据进行拆分, 构建存储到不同的服务器上来减轻图数据库的压力.</p> </li> <li> <p>对于图数据的详细属性信息可以存储到ElasticSearch做复杂检索, 让图数据库专注于图分析和检索能力上(有插件支持). 可以参考<a href="https://blog.csdn.net/superman_xxx/article/details/106752758?spm=1001.2014.3001.5502" target="_blank" rel="noopener noreferrer">这篇文章</a>.</p> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">apoc.path.subgraphNodes</code>来遍历节点到所有关系<strong>远远快于</strong>使用多层关系查询, 因为多层关系查询实际会展开关系层数逐个查询.</p> </li> <li> <p>如果有确定的目标, 编写cypher语句时先match该目标再匹配路径, 如 <code class="language-plaintext highlighter-rouge">match (n:Person{name: 'Peter'}) return (n)-[]-&gt;()</code>, 而不是匹配路径再过滤路径上节点属性, 如<code class="language-plaintext highlighter-rouge">match p=(n)-[]-&gt;() where n.name='Peter' return p </code>. 后者会扫描全图.</p> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">neo4j-import</code>导入海量数据, 但该工具需要脱机并且只适用于空库, 数据可能还需要预处理生成CSV, 不过它的效率非常值得你这么做. 同时需要注意其导入时是可以用<strong>正则表达式</strong>来匹配多个文件名的（注意<strong>不是通配符</strong>），比如如下：</p> <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>bin/neo4j-admin import <span class="se">\</span>
	<span class="nt">--nodes</span><span class="o">=</span><span class="s2">"import/movies4-header.csv,import/movies4-part.*"</span> <span class="se">\</span>
	<span class="nt">--nodes</span><span class="o">=</span><span class="s2">"import/actors4-header.csv,import/actors4-part.*"</span> <span class="se">\</span>
	<span class="nt">--relationships</span><span class="o">=</span><span class="s2">"import/roles4-header.csv,import/roles4-part.*"</span>
</code></pre></div> </div> </li> <li> <p>双向关系会极大地影响图数据库的遍历性能, 尽可能地不要这样做.如果真的发生了, 也可以参考<a href="https://blog.csdn.net/superman_xxx/article/details/104791282?spm=1001.2014.3001.5502" target="_blank" rel="noopener noreferrer">这篇文章</a>进行删除.</p> </li> <li> <p>图数据库里的环路也会极大地影响查询性能, 我解决环路的方法是检测路径中是否存在相同的节点. 使用<code class="language-plaintext highlighter-rouge">apoc.coll.duplicates</code>可以返回集合中的重复项.</p> </li> <li> <p>超级节点指的是拥有非常多关系/边的一类节点. 超级节点的存在会极大地影响入库/检索/分析的效率.</p> <ul> <li>在图数据建模的时候就应该确定好实体应该表示成节点还是标签. 比如“国家”这个实体如果设计成节点, 那么就很容易成为超级节点, 但设计成标签则不会带来性能的影响.</li> <li>关系结构优化: 将超级节点与其他节点的关系按照时间或者其他的层次关系进行分组, 这样既能提高查询的并发性也可以减少对超级节点的遍历开销.</li> <li>标签细分: 比如原来的标签就是<strong>社交媒体</strong>, 那么就可以将其细分到某个<strong>具体的社交平台</strong>.</li> </ul> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">explain</code>和<code class="language-plaintext highlighter-rouge">profile</code>来分析cypher语句的性能, 前者不会执行语句而后者会实际执行.</p> </li> <li> <p>使用带有补全提示的<a href="https://github.com/nicolewhite/cycli" target="_blank" rel="noopener noreferrer">cycli</a>来帮助更高效地编写cypher语句, 使用<a href="https://www.yworks.com/neo4j-explorer/" target="_blank" rel="noopener noreferrer">yFiles</a>来对图进行可视化.</p> </li> <li> <p>删除两个节点之间的重复关系:</p> <div class="language-cypher highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">MATCH</span> <span class="n">p</span><span class="o">=</span><span class="ss">(</span><span class="py">A:</span><span class="n">Test</span> <span class="ss">{</span><span class="py">name:</span><span class="s1">'A'</span><span class="ss">})</span><span class="o">-</span><span class="ss">[</span><span class="n">r</span><span class="ss">]</span><span class="o">-&gt;</span><span class="ss">(</span><span class="py">B:</span><span class="n">Test</span> <span class="ss">{</span><span class="py">name:</span><span class="s1">'B'</span><span class="ss">})</span>
<span class="k">WITH</span> <span class="nf">ID</span><span class="ss">(</span><span class="n">r</span><span class="ss">)</span> <span class="k">AS</span> <span class="n">id</span><span class="ss">,</span><span class="n">r.name</span> <span class="k">AS</span> <span class="n">name</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="nf">COLLECT</span><span class="ss">(</span><span class="n">id</span><span class="ss">)</span> <span class="k">AS</span> <span class="n">relIds</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="n">relIds</span><span class="ss">,</span><span class="nf">SIZE</span><span class="ss">(</span><span class="n">relIds</span><span class="ss">)</span> <span class="k">AS</span> <span class="n">relIdsSize</span>
<span class="k">WHERE</span> <span class="n">relIdsSize</span><span class="o">&gt;</span><span class="mi">1</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="n">apoc.coll.subtract</span><span class="ss">(</span><span class="n">relIds</span><span class="ss">,</span> <span class="ss">[</span><span class="n">relIds</span><span class="ss">[</span><span class="mi">0</span><span class="ss">]])</span> <span class="k">AS</span> <span class="n">deleteRelIds</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="n">deleteRelIds</span>
<span class="k">MATCH</span><span class="w"> </span><span class="ss">()</span><span class="o">-</span><span class="ss">[</span><span class="n">r</span><span class="ss">]</span><span class="o">-</span><span class="ss">()</span> <span class="k">WHERE</span> <span class="nf">ID</span><span class="ss">(</span><span class="n">r</span><span class="ss">)</span> <span class="ow">IN</span> <span class="n">deleteRelIds</span> <span class="k">DELETE</span> <span class="n">r</span>
</code></pre></div> </div> <p>更多条件分支操作可以参考如下</p> <div class="language-cypher highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">CALL</span> <span class="n">apoc.do.case</span><span class="ss">([</span>
  <span class="n">relationship</span><span class="o">=</span><span class="mi">1</span><span class="ss">,</span>
  <span class="err">\</span><span class="s1">'MATCH (from:Label {hcode:$fromHcode}),(to:Label {hcode:$toHcode}) 
    MERGE (from)-[:NEXT]-&gt;(to)\',
  relationship=-1,
  \'MATCH (from:Label {hcode:$fromHcode}),(to:Label {hcode:$toHcode}) 
    MERGE (from)&lt;-[:NEXT]-(to)\'],
  \'\'</span><span class="ss">,</span>
  <span class="ss">{</span><span class="py">fromHcode:</span><span class="n">fromHcode</span><span class="ss">,</span><span class="py">toHcode:</span><span class="n">toHcode</span><span class="ss">})</span> 
<span class="k">YIELD</span> <span class="n">value</span> <span class="k">RETURN</span> <span class="n">value</span>
</code></pre></div> </div> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">apoc.cypher.parallel</code>并行执行查询, 例如如下会从名称列表中并行取出每个姓名, 搜索其邻居节点并返回姓名:</p> <div class="language-cypher highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">CALL</span> <span class="n">apoc.cypher.parallel</span><span class="ss">(</span>
  <span class="s1">'MATCH (p:Person{name:$name}) -[:FRIEND_OF]-&gt; (p1) RETURN p1.name AS name'</span><span class="ss">,</span> 
  <span class="ss">{</span><span class="py">name:</span><span class="ss">[</span><span class="s1">'John'</span><span class="ss">,</span><span class="s1">'Mary'</span><span class="ss">,</span><span class="s1">'Peter'</span><span class="ss">,</span><span class="s1">'Wong'</span><span class="ss">,</span><span class="s1">'Chen'</span><span class="ss">,</span><span class="s1">'Lynas'</span><span class="ss">,</span><span class="s1">'Smith'</span><span class="ss">,</span><span class="s1">'Anna'</span><span class="ss">]},</span>
  <span class="s1">'name'</span>
<span class="ss">)</span>
</code></pre></div> </div> </li> </ul> <h2 id="学习资料">学习资料</h2> <p>在学习图数据库和实践过程中其实积累了不少资料, 都是自己在初学和实践中遇到困难而去搜索的资料. 而其实这方面的资料差不多也就是这些. 基本上遇到了问题都能在这些地方找到答案.</p> <p><strong>主要资料</strong></p> <p>这些是学习和操作图数据库所必需了解的知识部分.</p> <ul> <li> <a href="https://neo4j.com/docs/getting-started/current/" target="_blank" rel="noopener noreferrer">The Neo4j Getting Started Guide</a>: Neo4j官方的入门指南</li> <li> <a href="https://neo4j.com/docs/cypher-manual/current/" target="_blank" rel="noopener noreferrer">Cypher Manual</a>: Cypher是Neo4j的查询语言, 查询语法比较简单直观, 但尽管如此, 如何判断Cypher语句正确/准确, 以及对Cypher语句进行优化是工作一直需要考虑的问题.</li> <li> <a href="https://neo4j.com/docs/operations-manual/current/" target="_blank" rel="noopener noreferrer">The Neo4j Operations Manual</a>: Neo4j给出的操作手册, 可以大致浏览其中的内容, 因为遇到的很多问题可能最终都指向这里的解答.</li> </ul> <p><strong>其他资料</strong></p> <p>以下资料并非不重要, 而是用于扩展自己的学习面.</p> <ul> <li> <a href="https://neo4j.com/docs/" target="_blank" rel="noopener noreferrer">Neo4j Documentation</a>: 这里列出了Neo4j的所有文档.</li> <li> <a href="https://neo4j.com/docs/python-manual/current/" target="_blank" rel="noopener noreferrer">The Neo4j Python Driver Manual</a>, Neo4j官方给出的Python driver手册.</li> <li> <a href="https://py2neo.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">The Py2neo Handbook</a>: Py2neo相比官方给出的Python driver, 简化和封装了跟Neo4j的连接操作.</li> <li> <a href="https://neo4j.com/labs/apoc/4.1/" target="_blank" rel="noopener noreferrer">APOC User Guide 4.1</a>: APOC是neo4j的插件之一, 能够扩充Neo4j的一些能力.</li> <li> <a href="https://github.com/graphfoundation/ongdb" target="_blank" rel="noopener noreferrer">ONgDB - fork of Neo4j Enterprise: Graphs for Everyone</a>: Neo4j的分支版本, 后续多节点部署会考虑使用这个.</li> <li> <a href="https://community.neo4j.com/" target="_blank" rel="noopener noreferrer">Neo4j community</a>: neo4j官方维护的论坛, 应该是最直接寻求答案的地方.</li> <li> <a href="http://neo4j.com.cn/" target="_blank" rel="noopener noreferrer">Neo4j 图数据库中文社区</a>: 国内的Neo4j中文社区.</li> <li> <a href="https://yc-ma.blog.csdn.net/" target="_blank" rel="noopener noreferrer">Tnoy.ma的csdn博客</a>: 里面有许多的文章介绍图数据库, <a href="https://crazyyanchao.github.io/blog/archive.html" target="_blank" rel="noopener noreferrer">Yc-Ma Blog</a> 疑似是作者的另一博客.</li> <li> <a href="https://blog.csdn.net/GraphWay" target="_blank" rel="noopener noreferrer">俞博士的csdn博客</a>: 作者应该是在Neo4j就职, 介绍的东西还蛮实际的, 并且有不少PPT方便理解.</li> <li> <a href="https://zhuanlan.zhihu.com/p/83964428" target="_blank" rel="noopener noreferrer">图数据库neo4j因果集群技术分析</a>: 非常详细地讲述了因果集群.</li> </ul> <p>实际过程中会有许多需要进行谷歌搜索的事情, 大部分参考于stackoverflow的回答.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0" style="text-align: center;"> © Copyright 2025 Song Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script src="/assets/js/zoom.js"></script> <script src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-ER5P9GS1T8"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-ER5P9GS1T8");</script> </body> </html>