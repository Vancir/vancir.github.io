<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://vancir.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://vancir.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-22T04:16:40+00:00</updated><id>https://vancir.github.io/feed.xml</id><title type="html">Song Liu</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">WinDBG CheatSheet</title><link href="https://vancir.github.io/blog/2022/windbg-cheatsheet/" rel="alternate" type="text/html" title="WinDBG CheatSheet"/><published>2022-10-24T10:00:00+00:00</published><updated>2022-10-24T10:00:00+00:00</updated><id>https://vancir.github.io/blog/2022/windbg-cheatsheet</id><content type="html" xml:base="https://vancir.github.io/blog/2022/windbg-cheatsheet/"><![CDATA[<h2 id="main-extensions">Main Extensions</h2> <h2 id="symbols">Symbols</h2> <ul> <li><code class="language-plaintext highlighter-rouge">.sympath</code>: get/set path for symbol search</li> <li><code class="language-plaintext highlighter-rouge">.sympath +XY</code>: append XY directory to the searched symbol path</li> <li><code class="language-plaintext highlighter-rouge">!sym noisy</code>: instructs windbg to display information about its search for symbols</li> <li><code class="language-plaintext highlighter-rouge">dt ntdll!*</code>: display all variables in ntdll</li> </ul> <h2 id="peb-and-teb">PEB and TEB</h2> <ul> <li><code class="language-plaintext highlighter-rouge">!peb</code>: display PEB</li> <li><code class="language-plaintext highlighter-rouge">dt nt!_PEB -r @$peb</code>: full PEB dump</li> <li><code class="language-plaintext highlighter-rouge">!teb</code>: display TEB</li> </ul> <p>Many WinDbg commands (<code class="language-plaintext highlighter-rouge">lm</code>, <code class="language-plaintext highlighter-rouge">!dlls</code>, <code class="language-plaintext highlighter-rouge">!imgreloc</code>, <code class="language-plaintext highlighter-rouge">!tls</code>, <code class="language-plaintext highlighter-rouge">!gle</code>) rely on the data retrieved from PEB and TEB</p> <h2 id="process-and-module">Process and Module</h2> <ul> <li><code class="language-plaintext highlighter-rouge">lm</code>: list modules</li> <li><code class="language-plaintext highlighter-rouge">lm vm kernel32</code>: verbose output for kernel32</li> <li><code class="language-plaintext highlighter-rouge">!dlls</code>: dislay list of modules with loader-specific information</li> <li><code class="language-plaintext highlighter-rouge">!dlls -c kernel32</code>: only display information of <code class="language-plaintext highlighter-rouge">kernel32</code></li> <li><code class="language-plaintext highlighter-rouge">!imgreloc</code>: display relocation information</li> <li><code class="language-plaintext highlighter-rouge">!dh kernel32</code>: display the header for kernel32</li> </ul> <h1 id="threads-information">Threads Information</h1> <ul> <li><code class="language-plaintext highlighter-rouge">~</code>: thread status for all threads</li> <li><code class="language-plaintext highlighter-rouge">~0</code>: thread status for thread 0</li> <li><code class="language-plaintext highlighter-rouge">~.</code>: thread status for currently active thread</li> <li><code class="language-plaintext highlighter-rouge">~*</code>: thread status for all threads with some extra info</li> <li><code class="language-plaintext highlighter-rouge">~* k</code>: call stacks for all threads ~ !uniqstack</li> </ul>]]></content><author><name></name></author><category term="windbg"/><category term="debug"/><summary type="html"><![CDATA[Main Extensions]]></summary></entry><entry><title type="html">Writing an LLVM Pass</title><link href="https://vancir.github.io/blog/2022/writing-an-llvm-pass/" rel="alternate" type="text/html" title="Writing an LLVM Pass"/><published>2022-09-05T10:00:00+00:00</published><updated>2022-09-05T10:00:00+00:00</updated><id>https://vancir.github.io/blog/2022/writing-an-llvm-pass</id><content type="html" xml:base="https://vancir.github.io/blog/2022/writing-an-llvm-pass/"><![CDATA[<h2 id="compile-llvm-from-source">Compile LLVM from source</h2> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@github.com:llvm/llvm-project.git
<span class="nb">pushd </span>llvm-project
    git checkout llvmorg-10.0.1
    <span class="nb">mkdir </span>build
    <span class="nb">pushd </span>build
        cmake <span class="nt">-G</span> <span class="s2">"Unix Makefiles"</span> <span class="se">\</span>
            <span class="nt">-DLLVM_ENABLE_PROJECTS</span><span class="o">=</span><span class="s2">"clang;libcxx;libcxxabi"</span> <span class="se">\</span>
            <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>DEBUG <span class="se">\</span>
            ../llvm
        cmake <span class="nt">--build</span> <span class="nb">.</span>
        make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
    <span class="nb">popd
popd</span>
</code></pre></div></div> <h2 id="commands">Commands</h2> <ul> <li>Generate LLVM IR:</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Textual form
clang -O1 -emit-llvm input.c -S -o out.ll
# Binary/bit-code form
clang -O1 -emit-llvm input.c -c -o out.bc
</code></pre></div></div> <ul> <li>Run <code class="language-plaintext highlighter-rouge">HelloWorld</code> pass with <code class="language-plaintext highlighter-rouge">opt</code></li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>opt <span class="nt">-load-pass-plugin</span> ./libHelloWorld.<span class="o">{</span>so|dylib<span class="o">}</span> <span class="nt">-passes</span><span class="o">=</span>hello-world <span class="nt">-disable-output</span> input_for_hello.ll
</code></pre></div></div>]]></content><author><name></name></author><category term="LLVM"/><category term="analysis"/><summary type="html"><![CDATA[Compile LLVM from source]]></summary></entry><entry><title type="html">回到2015年看看那时ClusterFuzz的设计</title><link href="https://vancir.github.io/blog/2021/the-design-of-clusterfuzz-in-2015/" rel="alternate" type="text/html" title="回到2015年看看那时ClusterFuzz的设计"/><published>2021-04-17T11:59:38+00:00</published><updated>2021-04-17T11:59:38+00:00</updated><id>https://vancir.github.io/blog/2021/the-design-of-clusterfuzz-in-2015</id><content type="html" xml:base="https://vancir.github.io/blog/2021/the-design-of-clusterfuzz-in-2015/"><![CDATA[<p>2015年彼时ClusterFuzz尚不够成熟但也已经是初见规模, ClusterFuzz作为Google目前开发了11年的平台, 其大概是19年才算是得以广泛运用. 网上公开了Abhishek Arya于2015年NullCon的<a href="https://nullcon.net/website/archives/ppt/goa-15/analyzing-chrome-crash-reports-at-scale-by-abhishek-arya.pdf">分享PPT</a>, 这应该也是他首次全面地介绍了ClusterFuzz的模块设计, 发展至今依旧保留来很多内容, 也是全网对于ClusterFuzz设计最深入的一份资料. 如果你发现NullCon官网上该PDF的<a href="https://nullcon.net/website/archives/ppt/goa-15/analyzing-chrome-crash-reports-at-scale-by-abhishek-arya.pdf">链接</a>已经失效, 那么你可以点击以下链接进行访问: <a href="https://www.yumpu.com/en/document/read/37169541/analyzing-chrome-crash-reports-at-scale-by-abhishek-arya">ClusterFuzz</a></p> <h2 id="architectural-overview">Architectural Overview</h2> <figure> <picture> <source media="(max-width: 480px)" srcset="https://i.loli.net/2021/04/16/qfylSnuEOhxFBHP-480.webp"/> <source media="(max-width: 800px)" srcset="https://i.loli.net/2021/04/16/qfylSnuEOhxFBHP-800.webp"/> <source media="(max-width: 1400px)" srcset="https://i.loli.net/2021/04/16/qfylSnuEOhxFBHP-1400.webp"/> <img class="img-fluid rounded " src="https://i.loli.net/2021/04/16/qfylSnuEOhxFBHP.png" height="230" style="display:block;margin:0 auto;" data-zoomable=""/> </picture> </figure> <p>首先ClusterFuzz进行了前后端分离, 而所谓的AppEngine其实是Google云平台的一项服务, 相当于提供了一个平台让开发者去运行自己的代码而无需关心平台的维护. ClusterFuzz不可免地依赖了Google的不少云服务, 像图片里还有Google Compute Engine, Google Cloud Storage, Datastore, Blobstore就是如此.</p> <p>前端提供了以下模块:</p> <ul> <li>ClusterFuzz UI: 前端的展示界面, 用户可以进行操作, 彼时的UI相比现在而言粗糙不少, 但展示文字内容肯定也没什么问题了.</li> <li>Task Pull Queues: 这应该是ClusterFuzz的任务队列, ClusterFuzz的后端定义了众多功能不同的task.</li> <li>High replication datastore: 存储持续fuzzing过程中产生的各种元数据, 其实对应的是如今的NDB.</li> <li>Blobstore: Blobstore现在应该是属于Google弃用的存储服务. 现今版本的ClusterFuzz在Blob上也是基于NDB实现的, 但也是因为这个历史原因, 所以单独抽出来作为blobs.py并保留了部分旧版本兼容代码. Blob则是指一些二进制数据, 比如binary, testcase, fuzzers, data bundles等.</li> </ul> <p>后端则是从Task Pull Queues里获取Task并以Bot为单位执行, 其中Fuzz Task则是负责对Fuzz Target进行测试. 而这里Bots的Local Storage从我认知来看已经移除了, 目前保存在本地的数据应该只剩下缓存数据以及状态监控统计数据, 其他的数据基本都上传到云服务去了.</p> <p>Glusterfs是一项分布式文件系统, 彼时被用于同步Bots之间的数据. 而目前版本已经移除了Glusterfs, 我自己也尚不清楚目前是如何处理Bots之间的数据同步问题, 印象里似乎并没有同步Bots之间的数据. 这有待我后续仔细阅读这部分的源码得出结论. Builder Bots也让我很迷惑, 但从名称来看应该是用于对源码的构建. 在目前的ClusterFuzz版本中我也尚未发现有这部分相关代码.</p> <h2 id="clusterfuzz的实现目标">ClusterFuzz的实现目标</h2> <p>ClusterFuzz有三个主要目标:</p> <ol> <li>自动完成Crash的检测, 分析和管理</li> <li>可复现的Crash结果以及最小化的Testcases</li> <li>实时的回归测试以及修复性测试</li> </ol> <h3 id="0x01-crash自动化检测分析管理">0x01 Crash自动化检测/分析/管理</h3> <h4 id="fuzzer编写要求">Fuzzer编写要求</h4> <p>Fuzzer应当具备相同的使用命令以供调用, 比如<code class="language-plaintext highlighter-rouge">run.* --input_dir=A --output_dir=B --no_of_files=C</code>设计一套统一的命令行选项. 定义标签前缀, 比如“fuzz-”, “http-”, “flag-”等等. 具备跨平台性, 支持对多种编程语言开发的软件进行Fuzz. 使用Data Bundle来统一管理Fuzz资源, 并且也可以提供其他的脚本比如launcher, coverage等.</p> <h4 id="持续fuzz平台的功能">持续Fuzz平台的功能</h4> <p>设置好环境并对项目代码进行构建, 能够运行应用程序以及相关的测试代码. 能调整平台的参数比如设置手势, 设置工具的选项, 增加超时限制等. 能解决程序等资源依赖问题, 并对产出的Crash进行复现和去重, 将Crash, 覆盖率, 统计数据等进行妥善保存等.</p> <h4 id="testcase的重复判定">Testcase的重复判定</h4> <p>禁用inline frames, 比如llvm-symbolizer关闭选项-inlining. 根据Crash Type, Crash State以及Security Flag来对Crash进行去重. 这里Crash State则是崩溃时StackTraces的前3个Frame, 并进行了一定的归一化, 比如保留namespace, 移除具体的line_numbers后作为特征进行去重. (这里的Security Flag我尚不清楚具体指的是什么, 但我想根据Crash Type和Crash State应该就能做到不错的去重效果了.)</p> <h3 id="fuzzer的类型">Fuzzer的类型</h3> <p>Fuzzer分为三种: 基于生成的Fuzzer, 基于变异的Fuzzer, 可进化的Fuzzer.</p> <p>基于生成的Fuzzer适用性更窄, 依赖于具体的格式或API. 能够迅速的找到Bug, 但无效也更快, 并且需要编写复杂的策略提高效果, 适合用于检验回归测试.</p> <p>基于变异的Fuzzer则依赖于初始测试的样例, 而策略比较简单, 能够很好地适用于文件格式fuzz, 协议fuzz, 并且可以源源不断地挖掘Bugs. 但也有一些难以解决的情况比如计算checksum, 数据压缩操作等.</p> <p>进化式Fuzzer则是基于反馈的Fuzzer, 目前主流的反馈指标则是使用的代码覆盖率. 代码在编译时会进行插装来反馈测试样例运行时的覆盖率信息, 并且通过共享存储聚合多个代码之间的覆盖率情况.</p> <p>代码覆盖率部分彼时还是使用的fuzzer_utils来控制, 但从目前来看这些这些API都有了比较大的变化. 彼时针对Testcase会有以下规则: 对于原始Testcase, 如果增加了新的覆盖分支, 那么就将其加入到Optimal文件列表里去, 而如果该测试用例没有产生新的覆盖的话, 那么就会将其删除. 而对于Testcase发生改动并且产出了新覆盖率的时候, 就会将其加入到Corpus和Optimal文件列表中去. (无新覆盖分支那么就直接忽略.)</p> <h3 id="内存调试工具">内存调试工具</h3> <p>Valgrind会产生10-300x的性能开销, 启动缓慢并且只能适用于堆漏洞, 因此并没有选择使用Valgrind.</p> <p>ClusterFuzz选择了结合使用多种内存调试工具.</p> <ul> <li>AddressSanitizer(ASan): 检测UAF, Buffer Overflows(heap, stack, globals), Stack-Use-After-Return, Container-Overflow等问题. CPU开销2x, 内存开销1.5x-3x</li> <li>ThreadSanitizer(TSan): 检测Data Race, ESP on UAF, object vptr. CPU开销4x-10x, 内存开销5x-8x</li> <li>MemorySanitizer(MSan): 检测Uninitialized Memory Reads. CPU开销3x, 内存开销2x</li> <li>UndefinedBehaviorSanitizer(UBSan): 检测多约19种类型的bugs, esp on type confusion等.</li> <li>还提高了一些其他的工具, 但我想应该并没有使用上: SyzyASAN以及DrMemory.</li> </ul> <h3 id="0x02-可复现的crash结果以及最小化testcases">0x02 可复现的Crash结果以及最小化Testcases</h3> <p>作者提出一种方式叫做Delta Debugging可以并行多线程地进行Minimize任务. 并且支持为某些文件类型进行Minimizer的定制.</p> <p>Minimizer首先会将Input进行token化, 并假定某组Token并不是Crash所需要的, 假设移除掉这些Token后再次执行, 如果程序崩溃, 那么我们的移除就是可靠的. 而没有复现Crash, 那么就将移除的Token再细分成更小的组.</p> <p>### 0x03 实时的回归测试以及修复性测试</p> <p>作者提出了一个工具叫FindIt, 可以用于找出崩溃相关的ChangeLog(CL). 它的执行过程如下:</p> <ol> <li>解析StackTrace获取相关的文件, 对应的崩溃代码行号.</li> <li>在回归测试范围内解析ChangeLog, 获得代码文件相关的CL编号.</li> <li>根据ChangeLog和之前解析的StackTrace, 对于一个CL编号, 如果该次改动影响了StackTrace中解析出来的代码行号位置, 那么就认为这个CL是可疑的. 并提供一个可疑CL列表.</li> <li>如果StackTrace没有关联到相应的Cl编号, 那么就展示Blame信息看谁负责该处代码.</li> </ol>]]></content><author><name></name></author><category term="clusterfuzz"/><category term="fuzzing"/><summary type="html"><![CDATA[2015年彼时ClusterFuzz尚不够成熟但也已经是初见规模, ClusterFuzz作为Google目前开发了11年的平台, 其大概是19年才算是得以广泛运用. 网上公开了Abhishek Arya于2015年NullCon的分享PPT, 这应该也是他首次全面地介绍了ClusterFuzz的模块设计, 发展至今依旧保留来很多内容, 也是全网对于ClusterFuzz设计最深入的一份资料. 如果你发现NullCon官网上该PDF的链接已经失效, 那么你可以点击以下链接进行访问: ClusterFuzz]]></summary></entry><entry><title type="html">关于ClusterFuzz以及规模化持续Fuzzing的笔记</title><link href="https://vancir.github.io/blog/2021/notes-about-clusterfuzz-and-continuous-fuzzing/" rel="alternate" type="text/html" title="关于ClusterFuzz以及规模化持续Fuzzing的笔记"/><published>2021-04-16T22:43:14+00:00</published><updated>2021-04-16T22:43:14+00:00</updated><id>https://vancir.github.io/blog/2021/notes-about-clusterfuzz-and-continuous-fuzzing</id><content type="html" xml:base="https://vancir.github.io/blog/2021/notes-about-clusterfuzz-and-continuous-fuzzing/"><![CDATA[<p>ClusterFuzz的魅力在于它向我打开了一扇大门, 在降低了Fuzzing的使用门槛的同时让Fuzzing易于规模化, 只需要编写少量的代码就能让fuzzer持续地运行下去为你服务, 将过程中的崩溃等统计信息实时地展现在你面前, 我觉得这极具诱惑力并且蕴含着庞大的价值, 这就像安全研究的一个梦想, 一直督促我去学习这方面的内容. 以下我将就OSS-Fuzz负责人Abhishek Arya于Black Hat Europe 2019发表的议题<a href="https://i.blackhat.com/eu-19/Wednesday/eu-19-Arya-ClusterFuzz-Fuzzing-At-Google-Scale.pdf">ClusterFuzz: Fuzzing At Google Scale</a>进行阐述.</p> <h2 id="持续fuzzing">持续Fuzzing</h2> <ul> <li>Fuzzing非常善于通过探索非预期的状态来找到Bugs.</li> <li>应当将Fuzzing无缝地嵌入到软件开发的生命周期里去, 用户提交类似单元测试一般的Fuzzer源码, 能通过Fuzzing规模化产出Bugs, Fuzzing Statistics和Code Coverage.</li> <li>ClusterFuzz的目的在于将Fuzzing生命周期中, 除“fuzzer编写”和“Bug修复”过程外的所有流程都自动化运行起来.</li> </ul> <h2 id="fuzzing生命周期">Fuzzing生命周期:</h2> <h3 id="0x01-write-fuzzers">0x01 Write fuzzers</h3> <p>fuzzing分为Blackbox fuzzing, Greybox fuzzing和Structure-aware fuzzing. 而对于Fuzzing规模化重要的不是增加服务器的CPU核心数, 而是引导开发者学习使用Fuzzing, 提供丰富的文档和示例便于编写Greybox fuzzer, 提供高效fuzzing的建议(种子池,字典等), 让Greybox fuzzing成为像单元测试那样的一等公民.</p> <h3 id="0x02-build-fuzzers">0x02 Build fuzzers</h3> <p>使用编译时插桩(ASan, MSan, 覆盖率插桩等), 跟fuzzing引擎或驱动链接起来(libFuzzer: clang -fsanitize=address,fuzzer). 确保Release版本经过了充分fuzzing, 持续地构建fuzzer(理想情况是能加入到已有的CI流程).</p> <h3 id="0x03-fuzz-at-scale">0x03 Fuzz at scale</h3> <ul> <li>Fuzzing任务管理: 可抢占VMs源源不断地产出新的Crashes, 非抢占式VMs则对Crashes进行处理(Minimize, Bisect等), 两种VMs都会将信息写入到Task queue以及DB上.</li> <li>挑选目标: 大型项目可能会包含有成千上万的fuzz目标, 因此需要具备自动发现fuzz目标的能力, 并且能根据fuzz目标的质量进行优先级挑选(高产出目标&gt;低产出目标&gt;无法正常启动的目标). 同时也可以针对Sanitizer进行优先级排列(ASan&gt;MSan&gt;Others(UBSan/CFI/TSAN))</li> <li>Fuzzing策略: 并没有完美的启发式搜索策略, 可参考的策略包含Corpus subset, Value profiling, Custom mutators, Limiting maximum length of inputs. 另外ClusterFuzz里还采用里Radamsa mutator和ML-based RNN mutator来增强Corpus.</li> <li>Fuzzing策略选择: 多臂老虎机(MAB)能够减少在低效fuzzing策略上的资源浪费, 尽量选择提高覆盖率的策略组合.</li> </ul> <h3 id="0x04-triage-crashes">0x04 Triage crashes</h3> <ul> <li>De-duplication: 基于Stacktraces对崩溃进行去重, 选取前3“有趣”的栈帧作为CrashState, 包含debug和release断言, 去除内联frames, 公共库和debug函数. 忽略OOM和超时相关的Stacktrace.</li> <li>Grouping: 第二阶段的去重(相对较慢), 使用编辑距离将所有相似的Crashes划分为同一个组, 去除那些只有轻微差异的相同crash, 就实际效果来看还不错.</li> <li>Testcase minimization: 缩减Testcase更利于root cause分析. Greybox fuzzer通常会提供工具进行快速的缩减, 而Blackbox fuzzers则会使用基于Delta debugging的缩减方法, 效率低一些但胜在可以并行化.</li> <li>Bisection: (这一段二分我不太懂, 我觉得需要阅读完ClusterFuzz源码后才能确定这里的二分是什么含义)</li> <li>Variant analysis: Crash可以在sanitizers, fuzzing engines, platforms, architectures体现出不同的特征.</li> <li>Automatic bug filing: 提供最小化的复现过程以及详细的崩溃报告</li> <li>Prioritization: 不要对Bugs做过于深入的分析, 因为这样并不适合大规模的任务. 最好是假设所有的内存破坏都是可利用的, 将这些问题抛出来让人来判断. 基于崩溃的类型以及崩溃发生点来对崩溃进行简单的优先级排序, 将更有价值的崩溃优先呈现出来.</li> <li>Fix verification: 验证Fix是否会造成崩溃, 并且关闭已经验证完毕的Bugs.</li> <li>Vulnerability reward program: 可以提供额外的PoC来辅助漏洞的触发和缩减其他环节的任务. 让Fuzzer能持续地报告bug并产生高质量的报告.</li> </ul> <h3 id="0x05-improving-fuzzers">0x05 Improving fuzzers</h3> <p>对Fuzzer的运行情况, Crash的详细信息进行数据收集和统计. 生成代码覆盖率的报告.</p> <h2 id="理想的持续集成平台">理想的持续集成平台</h2> <ul> <li>Fuzzing能融入到普通软件开发过程的一部分</li> <li>可以结合不同的Fuzzing引擎和策略进行大规模测试</li> <li>大型的软件项目可以仅由一个小团队负责维护的持续fuzzing平台进行高效fuzz.</li> <li>将Fuzzing作为持续集成CI的一部分, 不断地在回归测试中捕获Bugs</li> <li>平台也能用于对于一个fuzzer进行性能测试的解决方案</li> <li>能持续地去提高fuzzing的效率.</li> <li>能支持对更多的编程语言开发的软件进行测试.</li> </ul>]]></content><author><name></name></author><category term="clusterfuzz"/><category term="fuzzing"/><summary type="html"><![CDATA[ClusterFuzz的魅力在于它向我打开了一扇大门, 在降低了Fuzzing的使用门槛的同时让Fuzzing易于规模化, 只需要编写少量的代码就能让fuzzer持续地运行下去为你服务, 将过程中的崩溃等统计信息实时地展现在你面前, 我觉得这极具诱惑力并且蕴含着庞大的价值, 这就像安全研究的一个梦想, 一直督促我去学习这方面的内容. 以下我将就OSS-Fuzz负责人Abhishek Arya于Black Hat Europe 2019发表的议题ClusterFuzz: Fuzzing At Google Scale进行阐述.]]></summary></entry><entry><title type="html">我在学习和实践图数据库 Neo4j 的漫漫成长路</title><link href="https://vancir.github.io/blog/2021/the-journey-of-learning-neo4j/" rel="alternate" type="text/html" title="我在学习和实践图数据库 Neo4j 的漫漫成长路"/><published>2021-02-11T21:11:22+00:00</published><updated>2021-02-11T21:11:22+00:00</updated><id>https://vancir.github.io/blog/2021/the-journey-of-learning-neo4j</id><content type="html" xml:base="https://vancir.github.io/blog/2021/the-journey-of-learning-neo4j/"><![CDATA[<h2 id="什么是图数据库和neo4j">什么是图数据库和Neo4j?</h2> <p>传统关系型数据库通过文档字段来建立数据的关联, 但是这并不利于海量数据背景下的关系推导. 图数据库应运而生, 图数据库的上层就是我们熟悉的图网络结构, 而下层则是对图结构进行了性能优化, 使之能进行快速的关系推导. 图数据库在知识图谱(比如社交关系推导)和图神经网络(GNN)上有很大的应用.</p> <p><a href="https://github.com/neo4j/neo4j">Neo4j</a>是业界主流的图数据库, 数据库目前排名是19(参见<a href="https://db-engines.com/en/ranking">DB-Engines Ranking</a>), 以点/关系进行存储, 支持百亿级别的查询. Neo4j分为免费的社区版和付费的企业版. 社区版只能进行单机部署, 企业版可以部署集群且性能上有着诸多优化, 以及解锁了诸多限制. <a href="https://github.com/graphfoundation/ongdb">ONgDB</a> 是Neo4j付费闭源前的分支版本, 目前的最新版本为3.6.2, 跟Neo4j企业版本3.6功能相差无几.</p> <h2 id="ongdb因果集群部署">ONgDB因果集群部署</h2> <p>因果集群基于Raft协议开发, Raft是一种更加易于理解的一致性算法, 可支持大规模和多拓扑结构的数据环境. 因果集群主要有以下两大特点:</p> <ol> <li> <p>安全性：核心服务器(Core)为事物平台处理提供了容错平台</p> </li> <li> <p>可扩展性：只读副本(Read Replica)为图查询提供了一个大规模高可扩展的平台</p> </li> </ol> <p>集群部署会有一些坑点，也许是版本迭代升级出现的新问题，从网上搜集的现有资料并没有提及到这些问题和解决方法。</p> <p>首先我的使用的版本是<code class="language-plaintext highlighter-rouge">ongdb-enterprise-3.6.2</code>，这是我之前就下载好存本地的，但此时在ONgDB仓库里将之前发布的版本都删除了（我推测是因为跟Neo4j打官司的原因），只留下约一个月前发布的<a href="https://github.com/graphfoundation/ongdb/releases/tag/1.0.0-alpha01">1.0.0-alpha01</a>版本，这也是ONgDB正式发布的第一个alpha测试版本，原先虽然名为ONgDB但其实代码里面都是以neo4j来命名，而这个<code class="language-plaintext highlighter-rouge">1.0.0</code>则将名称都改为了ongdb。并且ongdb和neo4j在配置上也并不完全一致，比如因果集群部分配置就是这样。我在使用1.0.0版本进行部署的时候主节点会卡在<code class="language-plaintext highlighter-rouge">Attempting to connect to the other cluster members</code>阶段，而ONgDB的文档内容非常少且网站也挂了，确认我配置没有问题后，我选择切回了旧的<code class="language-plaintext highlighter-rouge">ongdb-enterprise-3.6.2</code>版本。（并且此时ongdb-apoc还不兼容1.0.0版本）</p> <p>我测试使用的是三台服务器，需要先配置好SSH密钥，让这三台服务器能通过SSH直接登录到彼此服务器。</p> <p>随后参考Neo4j的集群配置文档，为配置文件<code class="language-plaintext highlighter-rouge">conf/neo4j.conf</code>改动以下内容（注意：尽量去找配置文件内已有的项进行修改，而不是直接在文件末尾新增，因为多个相同项Neo4j只取第一项作为结果）：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dbms.default_listen_address<span class="o">=</span>0.0.0.0
<span class="c"># 其他服务器用该地址来连接到节点，设定为节点的IP即可（无需端口）</span>
dbms.default_advertised_address<span class="o">=</span>core03.example.com
<span class="c"># 指定节点是核心节点还是冗余节点</span>
dbms.mode<span class="o">=</span>CORE
<span class="c"># 集群内所有节点的地址，集群节点启动后会不断通过该列表探测活跃的成员，默认端口5000</span>
causal_clustering.initial_discovery_members<span class="o">=</span>core01.example.com:5000,core02.example.com:5000,core03.example.com:5000
<span class="c"># （可选）该选项能避免集群在选举新的主节点前预先选举候选节点，这样就能避免因网络原因无法选举</span>
causal_clustering.enable_pre_voting<span class="o">=</span><span class="nb">true</span>
</code></pre></div></div> <p>所有节点的配置上其实除了<code class="language-plaintext highlighter-rouge">dbms.default_advertised_address</code>需要设置为自己的IP地址外，其他的配置都是一致的（当然还有mode你可以自己选定是作为核心节点还是冗余节点）。</p> <p>配置完后逐个启动各个节点即可，如果没有成功启动，那么很有可能是数据不一致带来的问题，建议先将<code class="language-plaintext highlighter-rouge">data</code>清空或重命名其他名称，保证集群内各节点的<code class="language-plaintext highlighter-rouge">data</code>都是一致的，重新启动图数据库。</p> <p><strong>一些报错信息及解决办法</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">Waiting to hear from leader</code>： 清空<code class="language-plaintext highlighter-rouge">data</code>或者重命名成其他名称</li> <li><code class="language-plaintext highlighter-rouge">Unable to find transaction 1 in any of my logical logs</code>： 数据不一致造成的问题，可以尝试清空<code class="language-plaintext highlighter-rouge">data</code>或者<code class="language-plaintext highlighter-rouge">neo4j-admin unbind --database=graph.db</code></li> <li>对于因果集群要想使用neo4j-import导入全量数据，也会存在数据不一致造成启动失败的问题，所以官方给出的实践方案是，在一个节点上成功导入数据后，使用scp或rsync等工具直接导入的数据库传输到集群内其他节点服务器上。当然如果依然有报错情况的话，还需要执行<code class="language-plaintext highlighter-rouge">neo4j-admin unbind --database=graph.db</code>来解除绑定。</li> </ul> <p>集群成功部署后，就可以通过<code class="language-plaintext highlighter-rouge">call dbms.cluster.overview()</code>和<code class="language-plaintext highlighter-rouge">call dbms.cluster.routing.getServers()</code>来查看集群成员角色和请求路由信息。默认第一个启动的节点为作为主节点，其他节点则作为从节点。主节点负责协调集群并接受所有的写入，数据改动会同步到所有从节点上，主节点挂掉则其他从节点就会开始进行选举，投票出新的节点来作为主节点进行服务，集群在可用性上有很大的强化。</p> <p>集群的连接方式基本也没有多少变化，原先单实例时的协议头为<code class="language-plaintext highlighter-rouge">bolt://</code>，而启用了路由的协议头则变更为<code class="language-plaintext highlighter-rouge">bolt+routing://</code>，协议头后面跟任意集群内节点的地址即可。当然集群内各节点也依然可以使用<code class="language-plaintext highlighter-rouge">bolt://</code>协议头单独用来查询数据（注意可读不一定可写）。另外要注意自己使用的驱动是否支持直接使用<code class="language-plaintext highlighter-rouge">bolt+routing://</code>协议头，像py2neo就不支持直接改协议头，但是可以在初始化Graph对象时增加<code class="language-plaintext highlighter-rouge">routing=True</code>选项启用路由模式。</p> <h2 id="关于性能优化的技巧">关于性能优化的技巧</h2> <ul> <li> <p>图数据库配置<code class="language-plaintext highlighter-rouge">conf/neo4j.con</code>, 可以使用<code class="language-plaintext highlighter-rouge">bin/neo4j-admin memrec</code>来查看推荐的配置.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 堆内存</span>
dbms.memory.heap.initial_size<span class="o">=</span>16384m
dbms.memory.heap.max_size<span class="o">=</span>16384m
<span class="c"># 页面缓存</span>
dbms.memory.pagecache.size<span class="o">=</span>80g
</code></pre></div> </div> </li> <li> <p>创建索引来提高检索速度: <code class="language-plaintext highlighter-rouge">create index on :Person(firstname)</code>, 使用<code class="language-plaintext highlighter-rouge">:schema</code>可以确认索引状态, 索引状态为ONLINE则表示索引已经生效.</p> </li> <li> <p>数据预热: 预先进行全图的查询来将图数据载入到缓存里, 来加快检索速度.如<code class="language-plaintext highlighter-rouge">call apoc.warmup.run()</code>和<code class="language-plaintext highlighter-rouge">match (n) optional match (n)-[r]-&gt;() return count(n) + count(r)</code></p> </li> <li> <p>根据情况将不同类型不同场景的数据进行拆分, 构建存储到不同的服务器上来减轻图数据库的压力.</p> </li> <li> <p>对于图数据的详细属性信息可以存储到ElasticSearch做复杂检索, 让图数据库专注于图分析和检索能力上(有插件支持). 可以参考<a href="https://blog.csdn.net/superman_xxx/article/details/106752758?spm=1001.2014.3001.5502">这篇文章</a>.</p> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">apoc.path.subgraphNodes</code>来遍历节点到所有关系<strong>远远快于</strong>使用多层关系查询, 因为多层关系查询实际会展开关系层数逐个查询.</p> </li> <li> <p>如果有确定的目标, 编写cypher语句时先match该目标再匹配路径, 如 <code class="language-plaintext highlighter-rouge">match (n:Person{name: 'Peter'}) return (n)-[]-&gt;()</code>, 而不是匹配路径再过滤路径上节点属性, 如<code class="language-plaintext highlighter-rouge">match p=(n)-[]-&gt;() where n.name='Peter' return p </code>. 后者会扫描全图.</p> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">neo4j-import</code>导入海量数据, 但该工具需要脱机并且只适用于空库, 数据可能还需要预处理生成CSV, 不过它的效率非常值得你这么做. 同时需要注意其导入时是可以用<strong>正则表达式</strong>来匹配多个文件名的（注意<strong>不是通配符</strong>），比如如下：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/neo4j-admin import <span class="se">\</span>
	<span class="nt">--nodes</span><span class="o">=</span><span class="s2">"import/movies4-header.csv,import/movies4-part.*"</span> <span class="se">\</span>
	<span class="nt">--nodes</span><span class="o">=</span><span class="s2">"import/actors4-header.csv,import/actors4-part.*"</span> <span class="se">\</span>
	<span class="nt">--relationships</span><span class="o">=</span><span class="s2">"import/roles4-header.csv,import/roles4-part.*"</span>
</code></pre></div> </div> </li> <li> <p>双向关系会极大地影响图数据库的遍历性能, 尽可能地不要这样做.如果真的发生了, 也可以参考<a href="https://blog.csdn.net/superman_xxx/article/details/104791282?spm=1001.2014.3001.5502">这篇文章</a>进行删除.</p> </li> <li> <p>图数据库里的环路也会极大地影响查询性能, 我解决环路的方法是检测路径中是否存在相同的节点. 使用<code class="language-plaintext highlighter-rouge">apoc.coll.duplicates</code>可以返回集合中的重复项.</p> </li> <li> <p>超级节点指的是拥有非常多关系/边的一类节点. 超级节点的存在会极大地影响入库/检索/分析的效率.</p> <ul> <li>在图数据建模的时候就应该确定好实体应该表示成节点还是标签. 比如“国家”这个实体如果设计成节点, 那么就很容易成为超级节点, 但设计成标签则不会带来性能的影响.</li> <li>关系结构优化: 将超级节点与其他节点的关系按照时间或者其他的层次关系进行分组, 这样既能提高查询的并发性也可以减少对超级节点的遍历开销.</li> <li>标签细分: 比如原来的标签就是<strong>社交媒体</strong>, 那么就可以将其细分到某个<strong>具体的社交平台</strong>.</li> </ul> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">explain</code>和<code class="language-plaintext highlighter-rouge">profile</code>来分析cypher语句的性能, 前者不会执行语句而后者会实际执行.</p> </li> <li> <p>使用带有补全提示的<a href="https://github.com/nicolewhite/cycli">cycli</a>来帮助更高效地编写cypher语句, 使用<a href="https://www.yworks.com/neo4j-explorer/">yFiles</a>来对图进行可视化.</p> </li> <li> <p>删除两个节点之间的重复关系:</p> <div class="language-cypher highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">MATCH</span> <span class="n">p</span><span class="o">=</span><span class="ss">(</span><span class="py">A:</span><span class="n">Test</span> <span class="ss">{</span><span class="py">name:</span><span class="s1">'A'</span><span class="ss">})</span><span class="o">-</span><span class="ss">[</span><span class="n">r</span><span class="ss">]</span><span class="o">-&gt;</span><span class="ss">(</span><span class="py">B:</span><span class="n">Test</span> <span class="ss">{</span><span class="py">name:</span><span class="s1">'B'</span><span class="ss">})</span>
<span class="k">WITH</span> <span class="nf">ID</span><span class="ss">(</span><span class="n">r</span><span class="ss">)</span> <span class="k">AS</span> <span class="n">id</span><span class="ss">,</span><span class="n">r.name</span> <span class="k">AS</span> <span class="n">name</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="nf">COLLECT</span><span class="ss">(</span><span class="n">id</span><span class="ss">)</span> <span class="k">AS</span> <span class="n">relIds</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="n">relIds</span><span class="ss">,</span><span class="nf">SIZE</span><span class="ss">(</span><span class="n">relIds</span><span class="ss">)</span> <span class="k">AS</span> <span class="n">relIdsSize</span>
<span class="k">WHERE</span> <span class="n">relIdsSize</span><span class="o">&gt;</span><span class="mi">1</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="n">apoc.coll.subtract</span><span class="ss">(</span><span class="n">relIds</span><span class="ss">,</span> <span class="ss">[</span><span class="n">relIds</span><span class="ss">[</span><span class="mi">0</span><span class="ss">]])</span> <span class="k">AS</span> <span class="n">deleteRelIds</span>
<span class="k">WITH</span> <span class="n">name</span><span class="ss">,</span><span class="n">deleteRelIds</span>
<span class="k">MATCH</span><span class="w"> </span><span class="ss">()</span><span class="o">-</span><span class="ss">[</span><span class="n">r</span><span class="ss">]</span><span class="o">-</span><span class="ss">()</span> <span class="k">WHERE</span> <span class="nf">ID</span><span class="ss">(</span><span class="n">r</span><span class="ss">)</span> <span class="ow">IN</span> <span class="n">deleteRelIds</span> <span class="k">DELETE</span> <span class="n">r</span>
</code></pre></div> </div> <p>更多条件分支操作可以参考如下</p> <div class="language-cypher highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CALL</span> <span class="n">apoc.do.case</span><span class="ss">([</span>
  <span class="n">relationship</span><span class="o">=</span><span class="mi">1</span><span class="ss">,</span>
  <span class="err">\</span><span class="s1">'MATCH (from:Label {hcode:$fromHcode}),(to:Label {hcode:$toHcode}) 
    MERGE (from)-[:NEXT]-&gt;(to)\',
  relationship=-1,
  \'MATCH (from:Label {hcode:$fromHcode}),(to:Label {hcode:$toHcode}) 
    MERGE (from)&lt;-[:NEXT]-(to)\'],
  \'\'</span><span class="ss">,</span>
  <span class="ss">{</span><span class="py">fromHcode:</span><span class="n">fromHcode</span><span class="ss">,</span><span class="py">toHcode:</span><span class="n">toHcode</span><span class="ss">})</span> 
<span class="k">YIELD</span> <span class="n">value</span> <span class="k">RETURN</span> <span class="n">value</span>
</code></pre></div> </div> </li> <li> <p>使用<code class="language-plaintext highlighter-rouge">apoc.cypher.parallel</code>并行执行查询, 例如如下会从名称列表中并行取出每个姓名, 搜索其邻居节点并返回姓名:</p> <div class="language-cypher highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CALL</span> <span class="n">apoc.cypher.parallel</span><span class="ss">(</span>
  <span class="s1">'MATCH (p:Person{name:$name}) -[:FRIEND_OF]-&gt; (p1) RETURN p1.name AS name'</span><span class="ss">,</span> 
  <span class="ss">{</span><span class="py">name:</span><span class="ss">[</span><span class="s1">'John'</span><span class="ss">,</span><span class="s1">'Mary'</span><span class="ss">,</span><span class="s1">'Peter'</span><span class="ss">,</span><span class="s1">'Wong'</span><span class="ss">,</span><span class="s1">'Chen'</span><span class="ss">,</span><span class="s1">'Lynas'</span><span class="ss">,</span><span class="s1">'Smith'</span><span class="ss">,</span><span class="s1">'Anna'</span><span class="ss">]},</span>
  <span class="s1">'name'</span>
<span class="ss">)</span>
</code></pre></div> </div> </li> </ul> <h2 id="学习资料">学习资料</h2> <p>在学习图数据库和实践过程中其实积累了不少资料, 都是自己在初学和实践中遇到困难而去搜索的资料. 而其实这方面的资料差不多也就是这些. 基本上遇到了问题都能在这些地方找到答案.</p> <p><strong>主要资料</strong></p> <p>这些是学习和操作图数据库所必需了解的知识部分.</p> <ul> <li><a href="https://neo4j.com/docs/getting-started/current/">The Neo4j Getting Started Guide</a>: Neo4j官方的入门指南</li> <li><a href="https://neo4j.com/docs/cypher-manual/current/">Cypher Manual</a>: Cypher是Neo4j的查询语言, 查询语法比较简单直观, 但尽管如此, 如何判断Cypher语句正确/准确, 以及对Cypher语句进行优化是工作一直需要考虑的问题.</li> <li><a href="https://neo4j.com/docs/operations-manual/current/">The Neo4j Operations Manual</a>: Neo4j给出的操作手册, 可以大致浏览其中的内容, 因为遇到的很多问题可能最终都指向这里的解答.</li> </ul> <p><strong>其他资料</strong></p> <p>以下资料并非不重要, 而是用于扩展自己的学习面.</p> <ul> <li><a href="https://neo4j.com/docs/">Neo4j Documentation</a>: 这里列出了Neo4j的所有文档.</li> <li><a href="https://neo4j.com/docs/python-manual/current/">The Neo4j Python Driver Manual</a>, Neo4j官方给出的Python driver手册.</li> <li><a href="https://py2neo.readthedocs.io/en/latest/">The Py2neo Handbook</a>: Py2neo相比官方给出的Python driver, 简化和封装了跟Neo4j的连接操作.</li> <li><a href="https://neo4j.com/labs/apoc/4.1/">APOC User Guide 4.1</a>: APOC是neo4j的插件之一, 能够扩充Neo4j的一些能力.</li> <li><a href="https://github.com/graphfoundation/ongdb">ONgDB - fork of Neo4j Enterprise: Graphs for Everyone</a>: Neo4j的分支版本, 后续多节点部署会考虑使用这个.</li> <li><a href="https://community.neo4j.com/">Neo4j community</a>: neo4j官方维护的论坛, 应该是最直接寻求答案的地方.</li> <li><a href="http://neo4j.com.cn/">Neo4j 图数据库中文社区</a>: 国内的Neo4j中文社区.</li> <li><a href="https://yc-ma.blog.csdn.net/">Tnoy.ma的csdn博客</a>: 里面有许多的文章介绍图数据库, <a href="https://crazyyanchao.github.io/blog/archive.html">Yc-Ma Blog</a> 疑似是作者的另一博客.</li> <li><a href="https://blog.csdn.net/GraphWay">俞博士的csdn博客</a>: 作者应该是在Neo4j就职, 介绍的东西还蛮实际的, 并且有不少PPT方便理解.</li> <li><a href="https://zhuanlan.zhihu.com/p/83964428">图数据库neo4j因果集群技术分析</a>: 非常详细地讲述了因果集群.</li> </ul> <p>实际过程中会有许多需要进行谷歌搜索的事情, 大部分参考于stackoverflow的回答.</p>]]></content><author><name></name></author><category term="neo4j"/><category term="optimization"/><summary type="html"><![CDATA[什么是图数据库和Neo4j?]]></summary></entry><entry><title type="html">实践: 使用Golang进行机器学习</title><link href="https://vancir.github.io/blog/2021/machine-learning-with-golang/" rel="alternate" type="text/html" title="实践: 使用Golang进行机器学习"/><published>2021-01-31T11:16:03+00:00</published><updated>2021-01-31T11:16:03+00:00</updated><id>https://vancir.github.io/blog/2021/machine-learning-with-golang</id><content type="html" xml:base="https://vancir.github.io/blog/2021/machine-learning-with-golang/"><![CDATA[<p>主流当下进行机器学习当然都是用的Python, 我的大部分工作也基本都是使用Python完成的. 但是Python的性能实在是太捉襟见肘, 所以我后面转向了Golang. 使用Golang进行机器学习对我而言是能更快地学习两者. 接下来我就来介绍在这过程中的学习和记录.</p> <h2 id="开发环境配置">开发环境配置</h2> <p>我的机器配置是双AMD的3700x+5700xt, 安装的黑苹果macOS Catalina 10.15.7这其实还挺麻烦的.</p> <ul> <li> <p>Tensorflow: 只是需要注意Python的版本. Tensorflow的支持版本是3.5-3.8我的版本是3.9, 所以我还需要安装3.8版本的Python</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># brew install python@3.8</span>
<span class="c"># echo 'export PATH="/usr/local/opt/python@3.8/bin:$PATH"' &gt;&gt; ~/.zshrc</span>
pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip
pip <span class="nb">install </span>tensorflow
</code></pre></div> </div> </li> <li> <p>Mercurial: <code class="language-plaintext highlighter-rouge">brew install mercurial</code></p> </li> <li> <p>Minikube: <code class="language-plaintext highlighter-rouge">brew install minikube</code></p> </li> <li> <p>Pachyderm: <code class="language-plaintext highlighter-rouge">brew tap pachyderm/tap &amp;&amp; brew install pachyderm/tap/pachctl@1.9</code></p> </li> </ul> <h2 id="golang进行数据处理">Golang进行数据处理</h2> <p>如果是手动解析数据的话, 需要手动定义数据格式, 并且对于异常数据的错误处理会很麻烦.</p> <ul> <li>csv文件使用<code class="language-plaintext highlighter-rouge">go-gota/gota/dataframe</code>进行处理.</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irisDF</span> <span class="o">:=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">ReadCSV</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">filter</span> <span class="o">:=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">F</span><span class="p">{</span>
	<span class="n">Colname</span><span class="o">:</span>    <span class="s">"species"</span><span class="p">,</span>
	<span class="n">Comparator</span><span class="o">:</span> <span class="s">"=="</span><span class="p">,</span>
	<span class="n">Comparando</span><span class="o">:</span> <span class="s">"Iris-versicolor"</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">versicolorDF</span> <span class="o">:=</span> <span class="n">irisDF</span><span class="o">.</span><span class="n">Filter</span><span class="p">(</span><span class="n">filter</span><span class="p">)</span><span class="o">.</span><span class="n">Select</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"sepal_width"</span><span class="p">,</span> <span class="s">"species"</span><span class="p">})</span><span class="o">.</span><span class="n">Subset</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">})</span>
</code></pre></div></div> <ul> <li>json文件使用<code class="language-plaintext highlighter-rouge">tidwall/gjson</code>和<code class="language-plaintext highlighter-rouge">tidwall/sjson</code>可以不需要定义schema就可以读取/设置</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">json</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="s">"../data/station_status.json"</span><span class="p">)</span>
<span class="n">value</span> <span class="o">:=</span> <span class="n">gjson</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">json</span><span class="p">),</span> <span class="s">"last_updated"</span><span class="p">)</span>

<span class="n">modified_json</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">sjson</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">json</span><span class="p">),</span> <span class="s">"last_updated"</span><span class="p">,</span> <span class="s">"123456"</span><span class="p">)</span>
<span class="n">modified_value</span> <span class="o">:=</span> <span class="n">gjson</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">modified_json</span><span class="p">,</span> <span class="s">"last_updated"</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>数据缓存: 使用<code class="language-plaintext highlighter-rouge">patrickmn/go-cache</code>在内存中缓存一系列数值</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span> <span class="o">:=</span> <span class="n">cache</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="m">5</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Minute</span><span class="p">,</span> <span class="m">30</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="s">"mykey"</span><span class="p">,</span> <span class="s">"myvalue"</span><span class="p">,</span> <span class="n">cache</span><span class="o">.</span><span class="n">DefaultExpiration</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">found</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"mykey"</span><span class="p">)</span>
</code></pre></div></div> <ul> <li> <p>数据本地缓存: <code class="language-plaintext highlighter-rouge">boltdb/bolt</code>被归档了, 所以我正在考虑其替代品<code class="language-plaintext highlighter-rouge">Badger</code></p> </li> <li> <p>数据版本控制: <code class="language-plaintext highlighter-rouge">minikube start &amp;&amp; pachctl deploy local</code> 在本地部署一个单机节点</p> </li> </ul> <h2 id="向量和矩阵操作">向量和矩阵操作</h2> <p>使用 <code class="language-plaintext highlighter-rouge">gonum/floats</code>进行向量操作:</p> <ul> <li>定义向量: <code class="language-plaintext highlighter-rouge">vector := []float64{11.0, 5.2, -1.3}</code></li> <li>点积: <code class="language-plaintext highlighter-rouge">dotProduct := floats.Dot(vectorA, vectorB)</code></li> <li>标准化: <code class="language-plaintext highlighter-rouge">floats.Scale(1.5, vectorA)</code></li> <li>范数: <code class="language-plaintext highlighter-rouge">normA := floats.Norm(vectorA, 2)</code></li> </ul> <p>使用<code class="language-plaintext highlighter-rouge">gonum/mat</code>进行操作</p> <ul> <li>定义向量: ` vectorA := mat.NewVecDense(3, []float64{11.0, 5.2, -1.3})`</li> <li>点积: <code class="language-plaintext highlighter-rouge">dotProduct := mat.Dot(vectorA, vectorB)</code></li> <li>标准化: <code class="language-plaintext highlighter-rouge">vectorA.ScaleVec(1.5, vectorA)</code></li> <li>范数: <code class="language-plaintext highlighter-rouge">normB := blas64.Nrm2(vectorB.RawVector())</code></li> </ul> <p>给定切片创建矩阵:</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">components</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="m">1.2</span><span class="p">,</span> <span class="o">-</span><span class="m">5.7</span><span class="p">,</span> <span class="o">-</span><span class="m">2.4</span><span class="p">,</span> <span class="m">7.3</span><span class="p">}</span>
<span class="n">a</span> <span class="o">:=</span> <span class="n">mat</span><span class="o">.</span><span class="n">NewDense</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="n">components</span><span class="p">)</span>
<span class="n">fa</span> <span class="o">:=</span> <span class="n">mat</span><span class="o">.</span><span class="n">Formatted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">FormatPython</span><span class="p">())</span>
</code></pre></div></div> <p>访问和设置矩阵数值</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">At</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
<span class="n">col</span> <span class="o">:=</span> <span class="n">mat</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">row</span> <span class="o">:=</span> <span class="n">mat</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

<span class="n">a</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">11.2</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">SetRow</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="m">14.3</span><span class="p">,</span> <span class="o">-</span><span class="m">4.2</span><span class="p">})</span>
<span class="n">a</span><span class="o">.</span><span class="n">SetCol</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="m">1.7</span><span class="p">,</span> <span class="o">-</span><span class="m">0.3</span><span class="p">})</span>
</code></pre></div></div> <p>加减乘等: <code class="language-plaintext highlighter-rouge">d.Add(a, b)</code>, <code class="language-plaintext highlighter-rouge">d.Sub(a, b)</code>, <code class="language-plaintext highlighter-rouge">d.Mul(a, b)</code>, <code class="language-plaintext highlighter-rouge">d.Pow(a, 5)</code>, <code class="language-plaintext highlighter-rouge">d.Apply(sqrt, a)</code></p> <p>行列式: <code class="language-plaintext highlighter-rouge">deta := mat.Det(a)</code>, 转置: <code class="language-plaintext highlighter-rouge">a.T()</code>, 逆矩阵: <code class="language-plaintext highlighter-rouge">aInverse.Inverse(a)</code></p> <h2 id="测量数据分布情况">测量数据分布情况</h2> <p>使用<code class="language-plaintext highlighter-rouge">gonum/stat</code> 和<code class="language-plaintext highlighter-rouge">montanaflynn/stats</code>进行基本的数据测量: 均值: <code class="language-plaintext highlighter-rouge">stat.Mean</code>, 众数: <code class="language-plaintext highlighter-rouge">stat.Mode</code>, 中位数: <code class="language-plaintext highlighter-rouge">stats.Median</code></p>]]></content><author><name></name></author><category term="golang"/><category term="ml"/><summary type="html"><![CDATA[主流当下进行机器学习当然都是用的Python, 我的大部分工作也基本都是使用Python完成的. 但是Python的性能实在是太捉襟见肘, 所以我后面转向了Golang. 使用Golang进行机器学习对我而言是能更快地学习两者. 接下来我就来介绍在这过程中的学习和记录.]]></summary></entry><entry><title type="html">论文: 开源包托管服务存在的供应链安全问题</title><link href="https://vancir.github.io/blog/2021/attacks-on-package-ecosystem/" rel="alternate" type="text/html" title="论文: 开源包托管服务存在的供应链安全问题"/><published>2021-01-07T23:32:40+00:00</published><updated>2021-01-07T23:32:40+00:00</updated><id>https://vancir.github.io/blog/2021/attacks-on-package-ecosystem</id><content type="html" xml:base="https://vancir.github.io/blog/2021/attacks-on-package-ecosystem/"><![CDATA[<p>现代编程开发会依赖于各种功能丰富的库包, 许多编程语言都维护着一套包管理工具以及相应的代码托管平台, 这些的出现大大推进了开发的效率, 同样开发者们也能轻松地编写代码包发布给社区, 和社区成员进行协作分享和互动. 但随着社区规模的日益扩大, 带来的就是依赖包的信任问题, 也就是供应链安全问题.</p> <p>本文我们来介绍一篇NDSS 2021上的论文<a href="https://arxiv.org/abs/2002.01139">“Towards Measuring Supply Chain Attacks on Package Managers for Interpreted Languages”</a>, 该论文大规模测量了当前主流的三个开源包托管平台(PyPi, Npm, RubyGems)上的代码, 并检出了339个新型恶意软件包, 其中有278(82%)个已被平台确认并移除.</p> <h2 id="包管理生态里的各个角色">包管理生态里的各个角色</h2> <p>首先作者将包管理生态分为了以下四种角色:</p> <ul> <li>托管平台维护者: 负责平台的运行,管理和维护, 为开发者提供软件包的搜索和安装功能. 通常包含一个提供和管理软件包的WEB应用程序(比如pypi.org)和一个帮助访问包的客户端应用程序(比如pip). 托管平台要求开发者注册账户才允许发布自己的代码包.</li> <li>软件包维护者: 负责软件包的日常维护和开发, 将代码托管到平台上, 通常使用平台如Github来进行协作开发, 可以使用持续集成/持续开发流程自动化地进行包的编译和部署.</li> <li>开发者: 普通开发者可以进行代码包的开发, 同时也是发布包的直接使用者.</li> <li>终端用户: 终端用户是供应链的下游, 虽然没有直接跟包和平台进行接触, 但用户会使用到最终的产品.</li> </ul> <figure> <picture> <source media="(max-width: 480px)" srcset="https://i.loli.net/2021/01/11/a17RFOnQsby9IZ4-480.webp"/> <source media="(max-width: 800px)" srcset="https://i.loli.net/2021/01/11/a17RFOnQsby9IZ4-800.webp"/> <source media="(max-width: 1400px)" srcset="https://i.loli.net/2021/01/11/a17RFOnQsby9IZ4-1400.webp"/> <img class="img-fluid rounded " src="https://i.loli.net/2021/01/11/a17RFOnQsby9IZ4.png" height="230" style="display:block;margin:0 auto;" data-zoomable=""/> </picture> </figure> <h2 id="平台方安全检查">平台方安全检查</h2> <p>论文作者对PyPi/Npm以及RubyGems的安全性分三部分(功能性/代码审查/响应措施)进行了测量评估.</p> <ul> <li>功能性检查侧重于检查平台方对包管理者的认证授权以及一些安全性的辅助功能.</li> <li>审核检查则在于平台方检出存在漏洞代码/恶意代码包的能力. 遗憾的是测试的三个平台没有一个具备该能力.</li> <li>补救响应功能则在于平台方在出现安全事故后是否积极地根据报告移除代码包, 封禁攻击者账户, 通知受害者尽快移除本地的危险包以及提供修复建议.</li> </ul> <figure> <picture> <source media="(max-width: 480px)" srcset="https://i.loli.net/2021/01/11/jtN3JHsyI1o8LTX-480.webp"/> <source media="(max-width: 800px)" srcset="https://i.loli.net/2021/01/11/jtN3JHsyI1o8LTX-800.webp"/> <source media="(max-width: 1400px)" srcset="https://i.loli.net/2021/01/11/jtN3JHsyI1o8LTX-1400.webp"/> <img class="img-fluid rounded " src="https://i.loli.net/2021/01/11/jtN3JHsyI1o8LTX.png" height="230" style="display:block;margin:0 auto;" data-zoomable=""/> </picture> </figure> <h2 id="攻击向量">攻击向量</h2> <ul> <li>利于平台服务的漏洞来篡改或注入恶意代码</li> <li>别名抢注: 注册跟热门包相似名称的包, 使不小心下载错误包的开发者执行恶意功能.</li> </ul> <p>恶意包的功能通常包括窃取用户的敏感信息, 注入后门, 加密文件并进行勒索, 用于挖矿, 传播病毒, 黑产等.</p> <h2 id="分析方法">分析方法</h2> <figure> <picture> <source media="(max-width: 480px)" srcset="https://i.loli.net/2021/01/11/I5liLzDCgwBoWqE-480.webp"/> <source media="(max-width: 800px)" srcset="https://i.loli.net/2021/01/11/I5liLzDCgwBoWqE-800.webp"/> <source media="(max-width: 1400px)" srcset="https://i.loli.net/2021/01/11/I5liLzDCgwBoWqE-1400.webp"/> <img class="img-fluid rounded " src="https://i.loli.net/2021/01/11/I5liLzDCgwBoWqE.png" height="230" style="display:block;margin:0 auto;" data-zoomable=""/> </picture> </figure> <ul> <li>元数据分析: 提取包的元数据信息(比如包名,作者,发布版本,下载次数,依赖等)标记出可能的恶意包.</li> <li>静态分析: <ul> <li>敏感API标记: 标记网络/文件系统/进程/代码生成相关的API, 并可用于后续的数据流分析.</li> <li>API使用情况分析: 将源码解析成AST形式然后搜寻标记API的使用情况.</li> <li>数据流分析: 检查代码的数据流的源, sink点和传播节点</li> </ul> </li> <li>动态分析: <ul> <li>执行代码包: 通过直接的install命令来安装, 对于嵌入在包内的二进制则在隔离的docker环境内进行执行, 对于import包则触发其包导入时的初始化逻辑, 对于导出函数则进行fuzz测试来触发其功能.</li> <li>动态跟踪: 使用sysdig来捕获代码运行时的系统调用trace.</li> </ul> </li> <li>启发式规则: 作者定义了一系列的启发式规则来帮助分析和检测.</li> </ul> <figure> <picture> <source media="(max-width: 480px)" srcset="https://i.loli.net/2021/01/11/r9P7aBwXqFyZCIG-480.webp"/> <source media="(max-width: 800px)" srcset="https://i.loli.net/2021/01/11/r9P7aBwXqFyZCIG-800.webp"/> <source media="(max-width: 1400px)" srcset="https://i.loli.net/2021/01/11/r9P7aBwXqFyZCIG-1400.webp"/> <img class="img-fluid rounded " src="https://i.loli.net/2021/01/11/r9P7aBwXqFyZCIG.png" height="230" style="display:block;margin:0 auto;" data-zoomable=""/> </picture> </figure>]]></content><author><name></name></author><category term="paper"/><category term="supplychain"/><summary type="html"><![CDATA[现代编程开发会依赖于各种功能丰富的库包, 许多编程语言都维护着一套包管理工具以及相应的代码托管平台, 这些的出现大大推进了开发的效率, 同样开发者们也能轻松地编写代码包发布给社区, 和社区成员进行协作分享和互动. 但随着社区规模的日益扩大, 带来的就是依赖包的信任问题, 也就是供应链安全问题.]]></summary></entry><entry><title type="html">20年的光怪陆离和21年的未来可期</title><link href="https://vancir.github.io/blog/2020/annual-summary-and-future-plan/" rel="alternate" type="text/html" title="20年的光怪陆离和21年的未来可期"/><published>2020-12-29T22:14:45+00:00</published><updated>2020-12-29T22:14:45+00:00</updated><id>https://vancir.github.io/blog/2020/annual-summary-and-future-plan</id><content type="html" xml:base="https://vancir.github.io/blog/2020/annual-summary-and-future-plan/"><![CDATA[<p>无论谁写下这篇博客, 思考最久的问题, 肯定都是自身吧. 我觉得只有此时此刻自己面对自己的内心时, 真诚的思考才能得出正确的答案, 即便所有的回答都不过像是回声一样, 在封闭的山谷里反复激荡,</p> <h2 id="振荡的疫情">振荡的疫情</h2> <p>如果要给20年定一个主线, 那无疑是疫情. 起初了解到武汉疫情的消息时, 谁能想到这场疫情会席卷全球并且持续这么长的时间. 20年过完春节我匆匆去往机场直飞北京, 当时跟出租车上的司机聊了起来. 他也知道武汉的疫情已经到了一个非常严重的地步, 他是武汉人, 但是没拗过家里老人把自己的儿子送回了武汉, 这一送进去就没有办法出来了, 还要冒着疫情的风险, 话语中无不是担忧. 后来我妈也跟我说到, 我当时要是晚走上一天, 小区也要封锁我也没法顺利回京. 疫情既已发生无可挽回, 我仿佛穿越时间回到了03年的非典现场, 恍若隔世犹如曾经柴静《看见》里描述的那样胆破心惊.</p> <p>大概年中的时候, 一位高中同学邀请我一起做一个有关疫情传播模型的研究, 我觉得正好是新冠肆虐的时期做起来还蛮有意思的. 疫情的传播是一个复杂的问题, 但从查阅的资料来看, 医学和计算的结合并没有到一个很高的水平, 甚至于说其实是有很多研究都还在早期阶段有着大量的工作极需完善, 不过确实也有可能是由于数据的匮乏, 想深入研究并非易事吧.</p> <h2 id="开始尝试理财">开始尝试理财</h2> <p>中国的通货膨胀应该是相当严重吧, 所以一直都是有钱花钱的态度. 我比较认可那一套”用金钱换时间”的说法, 但想想可悲的却是人们必须通过工作”拿时间换金钱”, 今年的一个成长就是开始了解理财. 我对理财的期待并非财生财利滚利, 能够跑赢通货膨胀就实属大幸. 由于疫情的影响, 资金大量流入股市, 所以这一整年来看, 只要克制自己没有追涨杀跌的话, 收益情况基本不会太差. 医疗相关的股票和基金当然是水涨船高了, 但我并没有购入, 并非是不认可医疗的机遇, 我只是单纯不相信这个国家除开消费以外的投资能长期稳定地盈利. 不过说来可笑, 什么科技半导体A股, 始终比不上人情社会饭桌上的白酒. 不过我也并没有投入多少资金到白酒上, 而是将大部分的资金都买入另一个长期稳定的混合型基金以及纳斯达克指数, 跑赢通胀就已然足够了, 投机市场我不期望有什么大富大贵, 能不被宰就已经是相当幸运了. 来年计划去银行开户, 降一下基金管理的费率, 再读几本理财相关的书目, 写一个简单的工具来管理自己的定投方案.</p> <h2 id="阅读的乐趣">阅读的乐趣</h2> <p>今年我给自己定的一个大目标就是阅读, 每一本书里都有着一个简缩的社会, 能从这个社会里读到什么全凭自己的理解. 我时常会思考很多观点是自己探求的还是别人灌输给我的, 我觉得在没有独立思考能力之前, 学到的一切结论都有可能是别人为某个目的灌输给我, 所以我更倾向的是自己去摸索和发现. 不过我阅读其实还有另一个原因, 就是我虽然没有喜欢的女生, 但我知道我喜欢的女生她一定会喜欢阅读. 所以就还是先从自己做起, 说不定能慢慢吸引到喜欢阅读的女生. 不过从结果来看这并没有什么作用, 我也不喜欢混什么圈子, 但如果再想想的话, 我觉得没有才是最好的结果.</p> <h2 id="少了那一步">少了那一步</h2> <p>当我周末无所事事的时候, 我就会想如果我真的没有了工作, 在我的设想里我并不会变得多快乐. 工作就像是一个强制把我拉出懒散的的念想, 借助这个念头我才能去更专注地完成工作之外我想完成我所热爱的事物. 当我意识到工作并不能让我得到成长的时候, 我就可以将工作和自学分的很开. 我想说个人的爱好喜乐, 都是活着的意义, 对技术的追求对安全的热爱, 很多时候我都觉得是一种自我价值的实现, 快感来自于掌握某项技术或应用于某种棘手的问题.</p> <p>但从这一年的结果来看, 我并没有做出让自己满意的工作. 我并没有轻视任何一项工作的意思, 因为我知道尽管看起来再简单不过的工作, 也需要花费足够的脑筋去完成优化. 我在工作里做了不少有趣的尝试, 大多是借助数据科学来解决一些传统方法难以解决的问题, 但限于知识水平, 我并没能把工作再往前推进一步, 我对问题的看法只有最初的一瞬, 一瞬间脑海里出现一个我完全没尝试过的方案, 但我深信这是可行的, 我所做的是将脑海里的雏形慢慢实现出来, 但实现完后我的脑海就是一片空白, 就像是踏入了初学的大门, 却发现门后面什么也没有, 没有人告诉我该如何找到通往进阶的路, 我正处于这个摸索的时候.</p> <h2 id="漫漫的学习路">漫漫的学习路</h2> <p>今年四月的时候也就是母校生日的那段时间, 我也如现在这样思考着, 我非常痛恨自己的处境. 我觉得自己带有着母校历史的光辉, 我希望自己并不止步于一个泯然大众的普通人, 而是尽力想在世界留下自己的足印. 所以给自己定了一个365天的挑战, 并迫切地希望能改变自己去追求新的处境. 但事实证明, 我的毅力只有预想里的一半, 这其中固然有一些原因, 但诚然在结果面前一切都不过是借口, 不一样的是我到现在也还没有放弃, 我还坚持在改变着.</p> <p>不过我也真的是受益良多, 这一年来我学到了很多有趣的知识. 如果说学习给我带来最明显的变化是什么, 我一定会说是视野. 刚参加工作的时候, 我没有任何独立的想法, 我对安全的认知仅限在我知道有哪些技术, 但如今我会知道有哪些地方可以思考. 视野放宽就会知道哪些地方存在隐患, 知道怎么去切入问题, 我将其总结为我这年来最大的学习收获.</p> <h2 id="研究和信心">研究和信心</h2> <p>这一年来, 多亏了上交研究组GoSSIP的长期无私分享, 让我也对论文产生了浓厚的兴趣, 算算自己业余时间也看了不少论文, 结果尚可吧. 我之所以没有选择考研而是直接工作, 是因为一种错觉认为研究生其实也学不到什么东西, 那些知识完全能靠自学消化吸收, 所以我一直是将我的前三年工作定位为我的”另类”研究生经历. 但阅读的论文多, 不明觉理囫囵吞枣就会有一种枯燥乏味的感觉, 当时也有请教GoSSIP里的群友, 李卷儒老师的话就像点破了我一样, 跟我说论文其实并非读一遍, 而是需要往复三五遍吸收的, 突然觉得从此阅读论文的角度和心态就也不一样了. 而且我还蛮感谢牙满小姐姐的认可, 聊天的时候跟我说希望我能来GoSSIP继续读研, 虽然我现在并不能立马去准备考研, 但这种认可让我在之后一直充满了信心, 让我知道尽管自己并没有成为独当一面的研究员, 但我依然拥有着这样的可能.</p> <h2 id="耀眼的偶像">耀眼的偶像</h2> <p>段老师是我的偶像, 在很早前我就梦想着能有机会见到段老师, 而在工作前离段老师最近的距离, 也仅仅是某次会议在台下远远地瞻仰着段老师, 听段老师分享最前沿的学术研究. 段老师对外一直给人的印象是很严谨地讨论和思考, 但近距离接触后发现其实段老师非常亲近没什么架子, 而且有着许多的可爱之处. 当偶像就在身边的时候, 感觉自己变成了婴孩, 做的一切扭捏的动作都不过是想吸引偶像的注意. 只是惜于自己的水平和不满足, 时常会幻想着在平行世界有另一个自己是发表了多篇顶会论文的博士, 那样才够得上跟段老师热烈地讨论学术细节.</p> <p>如果说今年受段老师感染最多的, 那就是对跑步的爱好和坚持了. 说来我的高中班主任老师也是一个长期坚持跑步锻炼的人, 只是当时我并没有某种决心. 如果自己在朝着某个方向努力的话, 那坚持是必不可少的品质. 我能认清自己的资质平庸, 最起码让我还有勇气去坚持和改变.</p> <p>身边还有着许多的榜样, 我都会非常羡慕他们, 但我也很清楚他们背后也有着许多不为人知的巨大努力. 我时常告诫自己, 周围人获取了怎样的成就这跟我一点关系也没有. 我警告自己不要陷入某种错觉, 拿别人的成就来作为自己吹嘘的材料. 如果要我总结从周围人身上学到了什么, 那我觉得应该是看见自己的不足. 我可以明显地感觉到自己的理论知识以及挖洞技术有着极大的欠缺, 而这也就是下一阶段我想着力的部分.</p> <h2 id="未来的期待">未来的期待</h2> <p>当我深入做一件事的时候, 我得到的经验就是任何一件事要想尽心尽力地完成都不简单, 去年我的期望仅仅是脑海中的几个零散的想法, 多多读书, 坚持学习, 但我自认为还算完成的不错, 如果是今年, 我可能会重点关注以下这些:</p> <ul> <li>保持对前沿论文的跟踪, 阅读和分享.</li> <li>保持长期的学习, 尽可能地记录下来.</li> <li>保持每周两到三次频率的锻炼.</li> <li>尽可能多的编写工具去减少繁冗的工作.</li> <li>将重心转移到漏洞的分析和挖掘上.</li> </ul> <p>我并没有定下具体的指标, 这有点违背SMART原则, 但平心而论, 无论如何当我定下某个计划的时候, 我所关心的并非是能不能完成计划本身, 而是制定计划时的勇气和决心. 如果说人生如一叶扁舟, 我不关心去向何处, 只留意我走了多远.</p> <p>谢谢20年受到的直接的间接的一切关心和帮助, 明天永远是未知的, 怎么想都比已成事实的昨天要有趣的多.</p>]]></content><author><name></name></author><category term="life"/><category term="future"/><summary type="html"><![CDATA[无论谁写下这篇博客, 思考最久的问题, 肯定都是自身吧. 我觉得只有此时此刻自己面对自己的内心时, 真诚的思考才能得出正确的答案, 即便所有的回答都不过像是回声一样, 在封闭的山谷里反复激荡,]]></summary></entry><entry><title type="html">论文: Angora加点优化策略的高效fuzzer</title><link href="https://vancir.github.io/blog/2020/angora-efficient-fuzzer/" rel="alternate" type="text/html" title="论文: Angora加点优化策略的高效fuzzer"/><published>2020-10-28T23:05:50+00:00</published><updated>2020-10-28T23:05:50+00:00</updated><id>https://vancir.github.io/blog/2020/angora-efficient-fuzzer</id><content type="html" xml:base="https://vancir.github.io/blog/2020/angora-efficient-fuzzer/"><![CDATA[<h2 id="简介">简介</h2> <p>Angora的主要目标是无需借助符号执行的情况下, 求解路径约束以提高分支覆盖率, 为达到该目标, 其引入了四种关键技术: 字节级污点跟踪, 上下文敏感的分支计数, 梯度下降法以及输入长度探索.</p> <ul> <li>上下文敏感的分支覆盖: AFL使用上下文无关的分支覆盖率来近似认为程序状态, 但实验表明上下文敏感能让Angora探索更广泛的状态</li> <li>字节级别的污点跟踪: 大多数的路径约束其实只跟输入里的少量字节相关, 因此Angora回去跟踪哪些字节跟对应的路径约束相关, 仅变异这些相关的字节而非整个输入.</li> <li>梯度下降法: Angora使用梯度下降法来解决路径约束.</li> <li>类型/形状推断: 输入中的许多字节经常会作为整体共同作用于一个值, 比如4字节用作32位有符号整数, 为了让梯度下降能有效地搜索, Angora设法找到上述的组并推断其类型.</li> <li>输入长度探索: 程序有时对输入有长度的要求, 符号执行和梯度下降都不能告诉Fuzzer何时应当增加输入的长度, Angora则会检测输入是否会影响到路径约束, 并适时增加输入长度.</li> </ul> <h2 id="设计">设计</h2> <h3 id="上下文敏感的分支覆盖">上下文敏感的分支覆盖</h3> <p>将分支定义为(prev, cur, context), prev和cur是当前分支前后基本块ID, 而context则是h(stack), h代表哈希函数, stack则是调用堆栈状态. 但用堆栈表示上下文的话, 遇到递归就会出现重复很多次. 因此h这个哈希函数仅将每个调用点计算一次来规避递归带来的重复问题.</p> <h3 id="字节级别的污点跟踪">字节级别的污点跟踪</h3> <p>Angora将程序的每个变量与一个污点标签tx做关联, tx表示可能流入x的输入中字节偏移量. 当然这里的污点标签需要满足快速的Insert/Find/Union操作, 因此作者通过构建二叉树来优化了时空效率.</p> <h3 id="梯度下降法和类型形状推断">梯度下降法和类型/形状推断</h3> <p>使用梯度下降法得到局部最优解作为路径约束的解, 而对于字节而言, 简单的应用梯度下降是合适的, 但对于多个字节组成的单个值, 在计算梯度的时候会出现问题, 所以作者必须解决类型推断的问题.</p> <p>为了解决该问题, Angora需要确定 (1) 输入里哪些字节被组合成单个值 (2) 判断这单个值其类型. 论文里将(1)称为形状推断(shape inference), 将(2)成为类型推断(type inference)</p> <ul> <li>shape inference: 初识时所有字节都视为独立的. 在污点分析期间, 当一条指令读取字节序列输入给变量, 且该字节序列长度与原始类型的大小匹配(例如1,2,4,8字节), 则将这些字节序列标记为同一个值</li> <li>type inference: Angora通过指令的语义作为依据来判断类型. 比如是一个对有符号整数进行运算的指令, Angora则将其操作数认作有符号整数, 如果一个数被同时用做有符号和无符号时, Angora则默认认为其是无符号. 当然推断不出来的话, Angora也没辙了.</li> </ul> <h3 id="输入长度探索">输入长度探索</h3> <p>污点跟踪期间, Angora会在read类函数调用时, 将目的内存地址和对应输入的字节偏移关联起来. Angora也会将read函数调用的返回值用特殊标签进行标记. 如果在条件语句中使用到了返回值同时又不满足约束条件了, 那么Angora就会增加输入的长度以满足分支的约束.</p>]]></content><author><name></name></author><category term="paper"/><category term="taint"/><summary type="html"><![CDATA[简介]]></summary></entry><entry><title type="html">论文: SAVIOR以Bug导向的混合模糊测试框架</title><link href="https://vancir.github.io/blog/2020/savior-bug-driven-hybrid-fuzzing/" rel="alternate" type="text/html" title="论文: SAVIOR以Bug导向的混合模糊测试框架"/><published>2020-10-27T00:33:45+00:00</published><updated>2020-10-27T00:33:45+00:00</updated><id>https://vancir.github.io/blog/2020/savior-bug-driven-hybrid-fuzzing</id><content type="html" xml:base="https://vancir.github.io/blog/2020/savior-bug-driven-hybrid-fuzzing/"><![CDATA[<h2 id="简介">简介</h2> <p>在混合执行有了较大进展的背景下, 针对于漏洞检测场景混合执行的效果并不乐观, 而作者主要认为有两个原因: 首先盲目选择种子用于混合执行以及不加重点地关注所有的代码, 其次就是混合模糊测试注重于让测试过程继续下去而非去检查内部的漏洞缺陷. 于是作者提出了SAVIOR, 它会优先考虑种子的混合执行并验证执行路径上所有易受攻击的程序位置.</p> <p>说白了, SAVIOR想解决混合模糊测试里乱选种子的行为, 并且希望以Bug为导向去选择种子. 那么具体的策略就是, 在测试前, SAVIOR会静态分析源代码并标记潜在的易受攻击位置. 此外, SAVIOR会计算每个分支可达的基本块集合, 在动态测试期间, SAVIOR优先考虑可以访问更重要分支的种子进行混合执行.</p> <p>除开上述说的能加快漏洞检测速度, SAVIOR还会验证混合执行引擎遍历过路径上标记的漏洞. 具体就是, SAVIOR综合了各个漏洞路径上的约束, 如果该约束在当前路径条件下可以满足, 那么SAVIOR就会求解该约束以构造输入进行测试. 否则SAVIOR会证明该漏洞在此路径上不可行.</p> <h2 id="设计">设计</h2> <h3 id="bug驱动优先级">Bug驱动优先级</h3> <p>Bug驱动的关键是找到一个方法去评估某个种子在混合执行时能暴露出的漏洞数量, 这个评估取决于两个先决条件:</p> <ul> <li>R1 - 种子执行完后评估可访问代码区域的方法</li> <li>R2 - 量化代码块中漏洞数量的指标</li> </ul> <p>针对R1, SAVIOR结合动静态分析去评估种子的可探索代码区域. 在编译期间, SAVIOR会从每个分支静态地计算可达的基本块集合, 在运行期间, SAVIOR则会在种子的执行路径上标记未探索的分支, 以及计算这些分支可访问的基本块集合.</p> <p>针对R2, SAVIOR则是利用UBSan来标注待测程序里的三种潜在的错误类型. 然后将每个代码区域中的标签计算为R2的定量指标. 同时SAVIOR也采用了一些过滤方法来删除UBSan的无用标签.</p> <h3 id="bug导向验证">Bug导向验证</h3> <p>该技术可以确保在到达了漏洞函数路径上能进行可靠的漏洞检测. 从模糊测试处给定种子, SAVIOR会将其执行起来并沿执行路径提取各个漏洞标签. 之后SAVIOR会检查当前路径条件下的可满足性, 满足即漏洞有效.</p> <h2 id="实现">实现</h2> <p>SAVIOR由多个部分组成: 构建在Clang+LLVM之上的工具链, 基于AFL的Fuzzer, KLEE移植过来的混合执行引擎和负责编排的协调器.</p> <p>SAVIOR的编译工具链可用于漏洞标记, 控制流的可达性分析以及不同组件的构建.</p> <p>漏洞标记则是基于UBSan, 当然UBSan有一些不如意的地方, SAVIOR对其进行了一些调整.</p> <p>可达性分析用于计算CFG中每个基本快可到达的漏洞标签的数量. 它分为两个阶段, 第一步是类似SVF方法去构建过程间CFG, 其首先会为每个函数构建过程内CFG再通过调用关系建立过程间的关系. 为了解决间接调用, 算法会反复执行Andersen的指针分析, 以防止SAVIOR丢失间接调用的函数别名信息, 也使得优先级划分不会漏算漏洞标签数量. 此外通过检查CFG, SAVIOR还提取了基本块和子对象之间的边, 以便后续在协调器的进一步使用. 第二步则是计算过程间CFG中每个基本块可到达的代码区域, 并计算这些区域中UBSan标记的数量, 以此作为该基本块的优先级指标.</p> <p>组件构建则是去编译三个binary: 一个用于fuzzer的binary, 一个用于协调器的SAVIOR-binary, 一个则是用于混合执行引擎的LLVM bitcode.</p> <p>协调器则是用于挑选优先级高的种子, 以及一些后续处理. 混合执行引擎则采取了一些策略去解决约束问题.</p>]]></content><author><name></name></author><category term="fuzzing"/><category term="bug"/><category term="paper"/><summary type="html"><![CDATA[简介]]></summary></entry></feed>